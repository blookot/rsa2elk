# Config file generated by RSA2ELK, see https://github.com/blookot/rsa2elk 
# Author: Vincent Maury
# Check all Netwitness parsers: https://github.com/netwitness/nw-logparsers/tree/master/devices/ (license: Apache 2.0)
# Check this link to search for source configuration guides: https://rsa.jiveon.com/community/products/netwitness/integrations/event-sources

##########
# CAUTION: check the "path" in input and "dictionary_path" in filter, as well as the "template" path in the elasticsearch output or "path" in the file output
##########

input {
#	syslog {
#		port => 514
#	}
#	file {
#		path => "/var/log/example.log"
#		start_position => "beginning"
#		sincedb_path => "/dev/null"
#	}
	generator {
		count => 1
		message => "a log line to test out"
	}
#	kafka {
#		codec => "json"
#		bootstrap_servers => "192.168.30.13:9092"
#		topics => ["mytopic"]
#		security_protocol => "SSL"
#		ssl_key_password => "{ssl_password}"
#		ssl_keystore_location => "/{keystore-absolute-path}"
#		ssl_keystore_password => "{keystore_password}"
#		ssl_truststore_location => "/{truststore-absolute-path}"
#		ssl_truststore_password => "{truststore_password}"
#	}
}

# Renaming a couple of fields
filter {
	mutate {
		rename => {
			"message" => "[event][original]"
			"host" => "[logstash][host]"
		}
	}
}

# Setting the device name and group
filter {
	mutate {
		add_field => {
			"[observer][product]" => "voltagesecuredata"
			"[observer][name]" => "Voltage SecureData"
			"[observer][type]" => "DLP"
		}
	}
}


# One single filter block for all headers and messages
filter {

################## HEADERS ##################

	# HEADER 0001
	# line in RSA: CEF:<fld>|Voltage|<product>|<version>|<id>|<event_description>|<severity>|<!payload>
	if ![logstash][headerfound] {
		dissect {
			mapping => { "[event][original]" => "CEF:%{fld}|Voltage|%{product}|%{version}|%{id}|%{event_description}|%{severity}|%{message}" }
			id => "header-0001"
			add_field => {
				"[rsa][header][id]" => "0001"
				"[rsa][message][id2]" => "voltagesecuredata_TVM"
				"[logstash][headerfound]" => true
			}
		}
	}
	# HEADER 0002
	# line in RSA: <hmonth> <hdate> <htime> <hhost> CEF:<fld>|Voltage|<product>|<version>|<id>|<event_description>|<severity>|<!payload>
	if ![logstash][headerfound] {
		dissect {
			mapping => { "[event][original]" => "%{hmonth} %{hdate} %{htime} %{hhost} CEF:%{fld}|Voltage|%{product}|%{version}|%{id}|%{event_description}|%{severity}|%{message}" }
			id => "header-0002"
			add_field => {
				"[rsa][header][id]" => "0002"
				"[rsa][message][id2]" => "voltagesecuredata_TVM"
				"[logstash][headerfound]" => true
			}
		}
	}



################## MsgId2 to Parser ##################

	translate {
		field => "[rsa][message][id2]"
		destination => "[logstash][msgparser][id]"
		dictionary_path => "msgid2parserid-voltagesecuredatamsg.json"
		fallback => ""
		override => true
	}


################## MESSAGES ##################

	# PARSER msgParserId0
	# line in RSA: operation=<action> AuthenticationMethod=<authmethod> authMethod=<authmethod> authMethodName=<authmethod> authType=<fld1> contentType=<fld2> path=<fld3> elapsedTimeMillis=<fld4> file=<filename> file_name=<filename> filename=<filename> filter=<fld5> ip=<hostip> new_syslog_host=<hostip> syslog_host=<fld6> details=<fld7> service=<service> src=<hostname> policy_url=<fld8> request=<url> url=<url> splunk_username=<username> User=<username> user=<username> username=<username> access_level=<fld9> algorithm=<fld10> applyTweak=<fld11> component=<obj_name> district=<domain> fullIdentity=<fld12> host=<fld13> identities=<fld14> identity=<fld15> defaultKeySize=<fld16> KeySize=<fld17> ldap_server=<fld18> merchantId=<fld19> methodName=<fld20> methodType=<fld21> proxyConnectionIp=<fld22> proxyType=<fld23> tenant=<fld24> type=<fld25> attemptedAuthMethods=<fld26> audit_appender=<fld27> audit_level=<fld28> AuditLevel=<fld29> AuditUserName=<fld30> auditUserName=<fld31> authMethods=<fld32> authTimeMillis=<fld33> authTokens=<fld34> CacheAuthTokens=<fld35> cacheAuthTokens=<fld36> CachedAuthentication=<fld37> CacheKeys=<fld38> CachePrefixFPEs=<fld39> cacheRefreshRatePositive=<fld40> computeChecksum=<fld41> count=<fld42> cvapi=<fld43> cvProduct=<fld44> cvtoolkit=<fld45> debug_level=<fld46> DefaultFPETime=<fld47> defaultFPETime=<fld48> enableCertAuth=<fld49> enabled=<fld50> EnableHTTP=<fld51> enableHTTP=<fld52> format=<fld53> format_list=<fld54> FormatName=<fld55> hsmEnabled=<fld56> identity_patterns=<fld57> idPatterns=<fld58> ipPatterns=<fld59> is_default_url=<fld60> is_java_pattern=<fld61> isUserPassSet=<fld62> keyId=<fld63> ldap_cache_timeout=<fld64> ldap_group_names=<fld65> ldap_server_group=<fld66> leadingDigits=<fld67> length=<dclass_counter1> local=<fld69> masked=<fld70> merchant_id=<fld71> name=<fld72> name_patterns=<fld73> new_log_file=<fld74> obviouslyProtectedMode=<fld75> out=<fld76> pathInfo=<fld77> phaseBit=<fld78> protect=<fld79> requestTimeMillis=<fld80> restart_required=<fld81> retain_leading=<fld82> retain_trailing=<fld83> retainLeading=<fld84> retainTrailing=<fld85> returnEncryptedKeyOption=<fld86> rollover=<fld87> servletContext=<fld88> servletPath=<fld89> short_fpe_mode=<fld90> shortLengthMinDigits=<fld91> skip_null_data=<fld92> spare_int=<fld93> spare_text=<fld94> timeMillis=<fld95> token_multiplexing_constant_fpe_time=<fld96> token_multiplexing_constant_key_size=<fld97> token_multiplexing_rollover=<fld98> trailingDigits=<fld99> tried_masked_access=<fld100> msg=<info> error=<result> os_service=<os> services=<service> model=<fld101> atalla_hsm_enabled=<fld102> hsm_enabled=<fld103> nrows=<fld104> ping_interval=<fld105> status=<disposition> feature=<fld106> exitcode=<resultcode>header=<fld1>header_line=<fld1> error_details=<result>
	if [logstash][msgparser][id] == "msgParserId0" {
		dissect {
			mapping => { "message" => "operation=%{action} AuthenticationMethod=%{authmethod} authMethod=%{authmethod} authMethodName=%{authmethod} authType=%{fld1} contentType=%{fld2} path=%{fld3} elapsedTimeMillis=%{fld4} file=%{filename} file_name=%{filename} filename=%{filename} filter=%{fld5} ip=%{hostip} new_syslog_host=%{hostip} syslog_host=%{fld6} details=%{fld7} service=%{service} src=%{hostname} policy_url=%{fld8} request=%{url} url=%{url} splunk_username=%{username} User=%{username} user=%{username} username=%{username} access_level=%{fld9} algorithm=%{fld10} applyTweak=%{fld11} component=%{obj_name} district=%{domain} fullIdentity=%{fld12} host=%{fld13} identities=%{fld14} identity=%{fld15} defaultKeySize=%{fld16} KeySize=%{fld17} ldap_server=%{fld18} merchantId=%{fld19} methodName=%{fld20} methodType=%{fld21} proxyConnectionIp=%{fld22} proxyType=%{fld23} tenant=%{fld24} type=%{fld25} attemptedAuthMethods=%{fld26} audit_appender=%{fld27} audit_level=%{fld28} AuditLevel=%{fld29} AuditUserName=%{fld30} auditUserName=%{fld31} authMethods=%{fld32} authTimeMillis=%{fld33} authTokens=%{fld34} CacheAuthTokens=%{fld35} cacheAuthTokens=%{fld36} CachedAuthentication=%{fld37} CacheKeys=%{fld38} CachePrefixFPEs=%{fld39} cacheRefreshRatePositive=%{fld40} computeChecksum=%{fld41} count=%{fld42} cvapi=%{fld43} cvProduct=%{fld44} cvtoolkit=%{fld45} debug_level=%{fld46} DefaultFPETime=%{fld47} defaultFPETime=%{fld48} enableCertAuth=%{fld49} enabled=%{fld50} EnableHTTP=%{fld51} enableHTTP=%{fld52} format=%{fld53} format_list=%{fld54} FormatName=%{fld55} hsmEnabled=%{fld56} identity_patterns=%{fld57} idPatterns=%{fld58} ipPatterns=%{fld59} is_default_url=%{fld60} is_java_pattern=%{fld61} isUserPassSet=%{fld62} keyId=%{fld63} ldap_cache_timeout=%{fld64} ldap_group_names=%{fld65} ldap_server_group=%{fld66} leadingDigits=%{fld67} length=%{dclass_counter1} local=%{fld69} masked=%{fld70} merchant_id=%{fld71} name=%{fld72} name_patterns=%{fld73} new_log_file=%{fld74} obviouslyProtectedMode=%{fld75} out=%{fld76} pathInfo=%{fld77} phaseBit=%{fld78} protect=%{fld79} requestTimeMillis=%{fld80} restart_required=%{fld81} retain_leading=%{fld82} retain_trailing=%{fld83} retainLeading=%{fld84} retainTrailing=%{fld85} returnEncryptedKeyOption=%{fld86} rollover=%{fld87} servletContext=%{fld88} servletPath=%{fld89} short_fpe_mode=%{fld90} shortLengthMinDigits=%{fld91} skip_null_data=%{fld92} spare_int=%{fld93} spare_text=%{fld94} timeMillis=%{fld95} token_multiplexing_constant_fpe_time=%{fld96} token_multiplexing_constant_key_size=%{fld97} token_multiplexing_rollover=%{fld98} trailingDigits=%{fld99} tried_masked_access=%{fld100} msg=%{info} error=%{result} os_service=%{os} services=%{service} model=%{fld101} atalla_hsm_enabled=%{fld102} hsm_enabled=%{fld103} nrows=%{fld104} ping_interval=%{fld105} status=%{disposition} feature=%{fld106} exitcode=%{resultcode}header=%{fld1}header_line=%{fld1} error_details=%{result}" }
			id => "msgParserId0"
			add_field => {
				"vid" => "%{id}"
				"p_id" => "%{id}"
				"[logstash][messagefound]" => true
			}
		}
	}


################## END OF MESSAGES ##################

# End of the filter block
}

# Enrich events using VALUEMAP
filter {
	translate {
		field => "[p_id]"
		destination => "[ec_subject]"
		dictionary => {
			"8100" => "User"
			"8101" => "User"
			"8102" => "User"
			"95022" => "User"
		}
		fallback => ""
		override => true
	}
}
filter {
	translate {
		field => "[p_id]"
		destination => "[ec_activity]"
		dictionary => {
			"8100" => "Logon"
			"8101" => "Logoff"
			"8102" => "Logon"
		}
		fallback => ""
		override => true
	}
}
filter {
	translate {
		field => "[p_id]"
		destination => "[ec_theme]"
		dictionary => {
			"8100" => "Authentication"
			"8101" => "Authentication"
			"8102" => "Authentication"
			"95022" => "Authentication"
		}
		fallback => ""
		override => true
	}
}
filter {
	translate {
		field => "[p_id]"
		destination => "[ec_outcome]"
		dictionary => {
			"8100" => "Success"
			"8101" => "Success"
			"8102" => "Failure"
			"95022" => "Failure"
		}
		fallback => ""
		override => true
	}
}
filter {
	translate {
		field => "[p_id]"
		destination => "[event_cat]"
		dictionary => {
			"0" => "1605000000"
			"4" => "1605000000"
			"5" => "1605000000"
			"6" => "1605000000"
			"7" => "1605000000"
			"8" => "1605000000"
			"9" => "1605000000"
			"10" => "1605000000"
			"11" => "1605000000"
			"12" => "1605000000"
			"13" => "1605000000"
			"14" => "1605000000"
			"15" => "1605000000"
			"16" => "1605000000"
			"30" => "1605000000"
			"33" => "1605000000"
			"42" => "1605000000"
			"43" => "1605000000"
			"1000" => "1605000000"
			"1100" => "1605000000"
			"1200" => "1605000000"
			"1300" => "1605000000"
			"1500" => "1605000000"
			"1510" => "1605000000"
			"1550" => "1605000000"
			"2000" => "1605000000"
			"2500" => "1605000000"
			"3057" => "1605000000"
			"3701" => "1605000000"
			"4001" => "1605000000"
			"4002" => "1605000000"
			"4901" => "1605000000"
			"4902" => "1605000000"
			"4903" => "1605000000"
			"4904" => "1605000000"
			"4905" => "1605000000"
			"5101" => "1605000000"
			"5102" => "1605000000"
			"6004" => "1605000000"
			"6005" => "1605000000"
			"6008" => "1605000000"
			"6009" => "1605000000"
			"6010" => "1605000000"
			"6011" => "1605000000"
			"6012" => "1605000000"
			"6013" => "1605000000"
			"6015" => "1605000000"
			"6016" => "1605000000"
			"6017" => "1605000000"
			"6018" => "1605000000"
			"6507" => "1605000000"
			"6508" => "1605000000"
			"6512" => "1605000000"
			"6513" => "1605000000"
			"6515" => "1605000000"
			"6517" => "1605000000"
			"6600" => "1605000000"
			"6601" => "1605000000"
			"6700" => "1605000000"
			"6705" => "1605000000"
			"7170" => "1605000000"
			"7501" => "1605000000"
			"7520" => "1605000000"
			"8100" => "1401060000"
			"8101" => "1401070000"
			"8102" => "1401070000"
			"8151" => "1605000000"
			"8155" => "1605000000"
			"8500" => "1605000000"
			"8501" => "1605000000"
			"9420" => "1605000000"
			"9410" => "1605000000"
			"92010" => "1605000000"
			"92100" => "1605000000"
			"95000" => "1605000000"
			"95010" => "1605000000"
			"95012" => "1605000000"
			"95020" => "1605000000"
			"95025" => "1605000000"
			"91000" => "1605000000"
			"91020" => "1605000000"
			"91030" => "1605000000"
			"91035" => "1605000000"
			"91100" => "1605000000"
			"95100" => "1605000000"
			"92000" => "1605000000"
			"92015" => "1605000000"
			"95022" => "1401030000"
			"95500" => "1605000000"
			"95001" => "1605000000"
			"95620" => "1605000000"
			"91005" => "1605000000"
			"91006" => "1605000000"
			"93600" => "1605000000"
			"200100" => "1605000000"
			"200200" => "1605000000"
			"34" => "1605000000"
			"35" => "1605000000"
			"36" => "1605000000"
			"37" => "1605000000"
			"7808" => "1605000000"
		}
		fallback => "1901000000"
		override => true
	}
}
filter {
	translate {
		field => "[event_cat]"
		destination => "[event_cat_name]"
		dictionary => {
			"1605000000" => "System.Normal Conditions"
			"1401030000" => "User.Activity.Failed Logins"
			"1401060000" => "User.Activity.Successful Logins"
			"1401070000" => "User.Activity.Logoff"
			"1901000000" => "Other.Default"
		}
		fallback => "Other.Default"
		override => true
	}
}


output {
#	if [logstash][headerfound] and [logstash][messagefound] {
#		elasticsearch {
#			hosts => ["https://elasticxxxxxx"]
#			index => "%{[observer][product]}-%{+YYYY.MM.dd}"
#			user => "logstash"
#			password => "abc"	# Better use keystore, cf https://www.elastic.co/guide/en/logstash/master/keystore.html
#			manage_template => true
#			template => "es-mapping-voltagesecuredatamsg.json"
#			template_name => "voltagesecuredata_template"
#			template_overwrite => true
#		}
#	} else {
#		# using a file output for logs that were not parsed correctly
#		# should you chose to send it to elasticsearch, please read https://discuss.elastic.co/t/latency-with-2-elasticsearch-systems/170074/2
#		file { path => "failed_logs-%{[observer][product]}-%{+YYYY-MM-dd}" }
#	}
	stdout {
		codec => rubydebug
	}
}

# Config file generated by RSA2ELK, see https://github.com/blookot/rsa2elk 
# Author: Vincent Maury
# Check all Netwitness parsers: https://github.com/netwitness/nw-logparsers/tree/master/devices/ (license: Apache 2.0)
# Check this link to search for source configuration guides: https://rsa.jiveon.com/community/products/netwitness/integrations/event-sources

##########
# CAUTION: check the "path" in input and "dictionary_path" in filter, as well as the "template" path in the elasticsearch output or "path" in the file output
##########

input {
#	syslog {
#		port => 514
#	}
#	file {
#		path => "/var/log/example.log"
#		start_position => "beginning"
#		sincedb_path => "/dev/null"
#	}
	generator {
		count => 1
		message => "a log line to test out"
	}
#	kafka {
#		codec => "json"
#		bootstrap_servers => "192.168.30.13:9092"
#		topics => ["mytopic"]
#		security_protocol => "SSL"
#		ssl_key_password => "{ssl_password}"
#		ssl_keystore_location => "/{keystore-absolute-path}"
#		ssl_keystore_password => "{keystore_password}"
#		ssl_truststore_location => "/{truststore-absolute-path}"
#		ssl_truststore_password => "{truststore_password}"
#	}
}

# Renaming a couple of fields
filter {
	mutate {
		rename => {
			"message" => "[event][original]"
			"host" => "[logstash][host]"
		}
	}
}

# Setting the device name and group
filter {
	mutate {
		add_field => {
			"[observer][product]" => "rsaflow"
			"[observer][name]" => "RSA Flow"
			"[observer][type]" => "Switch"
		}
	}
}


# One single filter block for all headers and messages
filter {

################## HEADERS ##################

	# HEADER 0001
	# line in RSA: <month> <day> <year> <time> <hostname> CEF:<cefversion>|RSA|{NetWitness NetFlow Collector|Security Analytics NetFlow Collector}|<version>|<messageid>|<event_description>|<severity>|<!payload>
	if ![logstash][headerfound] {
		grok {
			match => { "[event][original]" => "^(?<month>[^\s]*)[\s]+(?<day>[^\s]*)[\s]+(?<year>[^\s]*)[\s]+(?<time>[^\s]*)[\s]+(?<hostname>[^\s]*)[\s]+CEF:(?<cefversion>[^\|]*)\|RSA\|(NetWitness[\s]+NetFlow[\s]+Collector|Security[\s]+Analytics[\s]+NetFlow[\s]+Collector)\|(?<version>[^\|]*)\|(?<messageid>[^\|]*)\|(?<event_description>[^\|]*)\|(?<severity>[^\|]*)\|(?<message>.*)$" }
			id => "header-0001"
			add_field => {
				"[rsa][header][id]" => "0001"
				"[rsa][message][id2]" => "%{messageid}"
				"[logstash][headerfound]" => true
			}
		}
	}



################## MsgId2 to Parser ##################

	translate {
		field => "[rsa][message][id2]"
		destination => "[logstash][msgparser][id]"
		dictionary_path => "msgid2parserid-rsaflowmsg.json"
		fallback => ""
		override => true
	}


################## MESSAGES ##################

	# PARSER msgParserId0
	# line in RSA: Invalid=<cn_invalid> in=<rbytes> InPackets=<cn_rpackets> cnt=<event_counter> proto=<ip_proto> SrcTos=<cn_src_tos> TcpFlags=<tcp_flags> spt=<sport> src=<saddr> SrcMask=<smask> InputSnmp=<dinterface> dpt=<dport> dst=<daddr> DstMask=<dmask> OutputSnmp=<sinterface> Ipv4NextHop=<cs_ip_next_hop> SrcAs=<cn_asn_src> DstAs=<cn_asn_dst> BgpIpv4NextHop=<cn_bgpv4nxthop> MulDstPkts=<cn_mul_dst_pks> MulDstBytes=<cn_mul_dst_byt> FirstSwitched=<cn_f_switch> LastSwitched=<cn_l_switch> out=<sbytes> OutPackets=<cn_spackets> MinPacketLen=<cn_minpcktlen> MaxPacketLen=<cn_maxpcktlen> Ipv6SrcMask=<smask> Ipv6DstMask=<dmask> Ipv6FlowLabel=<cn_v6flowlabel> IcmpType=<icmptype> MulIgmpType=<cn_muligmptype> SamplingInterval=<cn_sampint> SamplingAlgorithm=<cn_sampalgo> FlowActiveTimeout=<cn_acttimeout> FlowInactiveTimeout=<cn_inacttimeout> EngineType=<cn_engine_type> EngineId=<cn_engine_id> TotalBytesExp=<cn_totbytsexp> TotalPacketsExp=<cn_totpcktsexp> TotalFlowsExp=<cn_totflowexp> cs1=<fld> Ipv4SrcPrefix=<cs_ipv4srcpre> Ipv4DstPrefix=<cs_ipv4dstpre> MplsTopLabelType=<cn_mplstoplabel> MplsTopLabelIpAddr=<cn_mplstoplabip> FlowSamplerId=<cn_flowsampid> FlowSamplerMode=<cn_flowsampmode> FlowSamplerRandIntv=<cn_flowsampintv> cs2=<fld> MinTtl=<cn_min_ttl> MaxTtl=<cn_max_ttl> Ipv4Ident=<cn_ipv4_ident> DstTos=<cn_dst_tos> smac=<smacaddr> dmac=<dmacaddr> SrcVlan=<cn_src_vlan> DstVlan=<cn_dst_vlan> IpProtoVersion=<cn_ip_proto_ver> deviceDirection=<fld1> Ipv6NextHop=<cs_v6nxthop> BgpIpv6NextHop=<cs_bgpv6nxthop> Ipv6OptionHeaders=<cn_v6optheaders> cs3=<fld> cs4=<fld> cs5=<fld> cs6=<fld> cs7=<fld> MplsLabel1=<cn_mpls_lbl_1> MplsLabel2=<cn_mpls_lbl_2> MplsLabel3=<cn_mpls_lbl_3> MplsLabel4=<cn_mpls_lbl_4> MplsLabel5=<cn_mpls_lbl_5> MplsLabel6=<cn_mpls_lbl_6> MplsLabel7=<cn_mpls_lbl_7> MplsLabel8=<cn_mpls_lbl_8> MplsLabel9=<cn_mpls_lbl_9> MplsLabel10=<cn_mpls_lbl_10> IfName=<cs_if_name> IfDesc=<cs_if_desc> SamplerName=<cs_sampler_name> InPermBytes=<cn_inpermbyts> InPermPackets=<cn_inpermpckts> cs8=<fld> UnixNSeconds=<cn_unixnanosecs> OctetsInFlow=<bytes> PacketsInFlow=<packets> SequenceCounter=<cn_seqctr> externalId=<hardware_id> SystemUpTime=<cn_sysuptime> TemplateId=<cn_template_id> rt=<fld2> Version=<version>
	if [logstash][msgparser][id] == "msgParserId0" {
		dissect {
			mapping => { "message" => "Invalid=%{cn_invalid} in=%{rbytes} InPackets=%{cn_rpackets} cnt=%{event_counter} proto=%{ip_proto} SrcTos=%{cn_src_tos} TcpFlags=%{tcp_flags} spt=%{sport} src=%{saddr} SrcMask=%{smask} InputSnmp=%{dinterface} dpt=%{dport} dst=%{daddr} DstMask=%{dmask} OutputSnmp=%{sinterface} Ipv4NextHop=%{cs_ip_next_hop} SrcAs=%{cn_asn_src} DstAs=%{cn_asn_dst} BgpIpv4NextHop=%{cn_bgpv4nxthop} MulDstPkts=%{cn_mul_dst_pks} MulDstBytes=%{cn_mul_dst_byt} FirstSwitched=%{cn_f_switch} LastSwitched=%{cn_l_switch} out=%{sbytes} OutPackets=%{cn_spackets} MinPacketLen=%{cn_minpcktlen} MaxPacketLen=%{cn_maxpcktlen} Ipv6SrcMask=%{smask} Ipv6DstMask=%{dmask} Ipv6FlowLabel=%{cn_v6flowlabel} IcmpType=%{icmptype} MulIgmpType=%{cn_muligmptype} SamplingInterval=%{cn_sampint} SamplingAlgorithm=%{cn_sampalgo} FlowActiveTimeout=%{cn_acttimeout} FlowInactiveTimeout=%{cn_inacttimeout} EngineType=%{cn_engine_type} EngineId=%{cn_engine_id} TotalBytesExp=%{cn_totbytsexp} TotalPacketsExp=%{cn_totpcktsexp} TotalFlowsExp=%{cn_totflowexp} cs1=%{fld} Ipv4SrcPrefix=%{cs_ipv4srcpre} Ipv4DstPrefix=%{cs_ipv4dstpre} MplsTopLabelType=%{cn_mplstoplabel} MplsTopLabelIpAddr=%{cn_mplstoplabip} FlowSamplerId=%{cn_flowsampid} FlowSamplerMode=%{cn_flowsampmode} FlowSamplerRandIntv=%{cn_flowsampintv} cs2=%{fld} MinTtl=%{cn_min_ttl} MaxTtl=%{cn_max_ttl} Ipv4Ident=%{cn_ipv4_ident} DstTos=%{cn_dst_tos} smac=%{smacaddr} dmac=%{dmacaddr} SrcVlan=%{cn_src_vlan} DstVlan=%{cn_dst_vlan} IpProtoVersion=%{cn_ip_proto_ver} deviceDirection=%{fld1} Ipv6NextHop=%{cs_v6nxthop} BgpIpv6NextHop=%{cs_bgpv6nxthop} Ipv6OptionHeaders=%{cn_v6optheaders} cs3=%{fld} cs4=%{fld} cs5=%{fld} cs6=%{fld} cs7=%{fld} MplsLabel1=%{cn_mpls_lbl_1} MplsLabel2=%{cn_mpls_lbl_2} MplsLabel3=%{cn_mpls_lbl_3} MplsLabel4=%{cn_mpls_lbl_4} MplsLabel5=%{cn_mpls_lbl_5} MplsLabel6=%{cn_mpls_lbl_6} MplsLabel7=%{cn_mpls_lbl_7} MplsLabel8=%{cn_mpls_lbl_8} MplsLabel9=%{cn_mpls_lbl_9} MplsLabel10=%{cn_mpls_lbl_10} IfName=%{cs_if_name} IfDesc=%{cs_if_desc} SamplerName=%{cs_sampler_name} InPermBytes=%{cn_inpermbyts} InPermPackets=%{cn_inpermpckts} cs8=%{fld} UnixNSeconds=%{cn_unixnanosecs} OctetsInFlow=%{bytes} PacketsInFlow=%{packets} SequenceCounter=%{cn_seqctr} externalId=%{hardware_id} SystemUpTime=%{cn_sysuptime} TemplateId=%{cn_template_id} rt=%{fld2} Version=%{version}" }
			id => "msgParserId0"
			add_field => {
				"event_type" => "flowdata"
				"product" => "Security Analytics NetFlow Collector"
				"[logstash][fullDateTimeString]" => "%{fld2}"
				"[logstash][messagefound]" => true
			}
		}
		if [logstash][fullDateTimeString] {
			date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
		}
	}


################## END OF MESSAGES ##################

# End of the filter block
}

# Enrich events using VALUEMAP
filter {
	translate {
		field => "[fld1]"
		destination => "[direction]"
		dictionary => {
			"1" => "outbound"
			"0" => "inbound"
		}
		fallback => ""
		override => true
	}
}
filter {
	translate {
		field => "[ip_proto]"
		destination => "[protocol]"
		dictionary => {
			"0" => "HOPOPT"
			"1" => "ICMP"
			"2" => "IGMP"
			"3" => "GGP"
			"4" => "IP"
			"5" => "ST"
			"6" => "TCP"
			"7" => "CBT"
			"8" => "EGP"
			"9" => "IGP"
			"10" => "BBN-RCC-M"
			"11" => "NVP-II"
			"12" => "PUP"
			"13" => "ARGUS"
			"14" => "EMCON"
			"15" => "XNET"
			"16" => "CHAOS"
			"17" => "UDP"
			"18" => "MUX"
			"19" => "DCN-MEAS"
			"20" => "HMP"
			"21" => "PRM"
			"22" => "XNS-IDP"
			"23" => "TRUNK-1"
			"24" => "TRUNK-2"
			"25" => "LEAF-1"
			"26" => "LEAF-2"
			"27" => "RDP"
			"28" => "IRTP"
			"29" => "ISO-TP4"
			"30" => "NETBLT"
			"31" => "MFE-NSP"
			"32" => "MERIT-INP"
			"33" => "SEP"
			"34" => "3PC"
			"35" => "IDPR"
			"36" => "XTP"
			"37" => "DDP"
			"38" => "IDPR-CMTP"
			"39" => "TP++"
			"40" => "IL"
			"41" => "IPv6"
			"42" => "SDRP"
			"43" => "IPv6-Rout"
			"44" => "IPv6-Frag"
			"45" => "IDRP"
			"46" => "RSVP"
			"47" => "GRE"
			"48" => "MHRP"
			"49" => "BNA"
			"50" => "ESP"
			"51" => "AH"
			"52" => "I-NLSP"
			"53" => "SWIPE"
			"54" => "NARP"
			"55" => "MOBILE"
			"56" => "TLSP"
			"57" => "SKIP"
			"58" => "IPv6-ICMP"
			"59" => "IPv6-NoNx"
			"60" => "IPv6-Opts"
			"61" => "AnyHost"
			"62" => "CFTP"
			"63" => "AnyNetwork"
			"64" => "SAT-EXPAK"
			"65" => "KRYPTOLAN"
			"66" => "RVD"
			"67" => "IPPC"
			"68" => "AnyFile"
			"69" => "SAT-MON"
			"70" => "VISA"
			"71" => "IPCV"
			"72" => "CPNX"
			"73" => "CPHB"
			"74" => "WSN"
			"75" => "PVP"
			"76" => "BR-SAT-MO"
			"77" => "SUN-ND"
			"78" => "WB-MON"
			"79" => "WB-EXPAK"
			"80" => "ISO-IP"
			"81" => "VMTP"
			"82" => "SECURE-VM"
			"83" => "VINES"
			"84" => "TTP"
			"85" => "NSFNET-IG"
			"86" => "DGP"
			"87" => "TCF"
			"88" => "EIGRP"
			"89" => "OSPFIGP"
			"90" => "Sprite-RP"
			"91" => "LARP"
			"92" => "MTP"
			"93" => "AX.25"
			"94" => "IPIP"
			"95" => "MICP"
			"96" => "SCC-SP"
			"97" => "ETHERIP"
			"98" => "ENCAP"
			"99" => "AnyPrivate"
			"100" => "GMTP"
			"101" => "IFMP"
			"102" => "PNNI"
			"103" => "PIM"
			"104" => "ARIS"
			"105" => "SCPS"
			"106" => "QNX"
			"107" => "A/N"
			"108" => "IPComp"
			"109" => "SNP"
			"110" => "Compaq-Pe"
			"111" => "IPX-in-IP"
			"112" => "VRRP"
			"113" => "PGM"
			"114" => "AnyHop"
			"115" => "L2TP"
			"116" => "DDX"
			"117" => "IATP"
			"118" => "STP"
			"119" => "SRP"
			"120" => "UTI"
			"121" => "SMP"
			"122" => "SM"
			"123" => "PTP"
			"124" => "ISIS"
			"125" => "FIRE"
			"126" => "CRTP"
			"127" => "CRUDP"
			"128" => "SSCOPMCE"
			"129" => "IPLT"
			"130" => "SPS"
			"131" => "PIPE Pr"
			"132" => "SCTP St"
			"133" => "FC Fi"
			"134" => "RSVP-E2E-"
			"255" => "Reserved"
		}
		fallback => ""
		override => true
	}
}


output {
#	if [logstash][headerfound] and [logstash][messagefound] {
#		elasticsearch {
#			hosts => ["https://elasticxxxxxx"]
#			index => "%{[observer][product]}-%{+YYYY.MM.dd}"
#			user => "logstash"
#			password => "abc"	# Better use keystore, cf https://www.elastic.co/guide/en/logstash/master/keystore.html
#			manage_template => true
#			template => "es-mapping-rsaflowmsg.json"
#			template_name => "rsaflow_template"
#			template_overwrite => true
#		}
#	} else {
#		# using a file output for logs that were not parsed correctly
#		# should you chose to send it to elasticsearch, please read https://discuss.elastic.co/t/latency-with-2-elasticsearch-systems/170074/2
#		file { path => "failed_logs-%{[observer][product]}-%{+YYYY-MM-dd}" }
#	}
	stdout {
		codec => rubydebug
	}
}

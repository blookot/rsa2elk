# Config file generated by RSA2ELK, see https://github.com/blookot/rsa2elk 
# Author: Vincent Maury
# Check all Netwitness parsers: https://github.com/netwitness/nw-logparsers/tree/master/devices/ (license: Apache 2.0)
# Check this link to search for source configuration guides: https://rsa.jiveon.com/community/products/netwitness/integrations/event-sources

##########
# CAUTION: check the "path" in input and "dictionary_path" in filter, as well as the "template" path in the elasticsearch output or "path" in the file output
##########

input {
#	syslog {
#		port => 514
#	}
#	file {
#		path => "/var/log/example.log"
#		start_position => "beginning"
#		sincedb_path => "/dev/null"
#	}
	generator {
		count => 1
		message => "a log line to test out"
	}
#	kafka {
#		codec => "json"
#		bootstrap_servers => "192.168.30.13:9092"
#		topics => ["mytopic"]
#		security_protocol => "SSL"
#		ssl_key_password => "{ssl_password}"
#		ssl_keystore_location => "/{keystore-absolute-path}"
#		ssl_keystore_password => "{keystore_password}"
#		ssl_truststore_location => "/{truststore-absolute-path}"
#		ssl_truststore_password => "{truststore_password}"
#	}
}

# Renaming a couple of fields
filter {
	mutate {
		rename => {
			"message" => "[event][original]"
			"host" => "[logstash][host]"
		}
	}
}

# Setting the device name and group
filter {
	mutate {
		add_field => {
			"[observer][product]" => "ibmicsf"
			"[observer][name]" => "IBM Mainframe ICSF"
			"[observer][type]" => "Mainframe"
		}
	}
}


# One single filter block for all headers and messages
filter {

################## HEADERS ##################

	# HEADER 0001
	# line in RSA: %IBMICSF-4: SMF_Type=82|SubType=<messageid>|<!payload>
	if ![logstash][headerfound] {
		dissect {
			mapping => { "[event][original]" => "%IBMICSF-4: SMF_Type=82|SubType=%{messageid}|%{message}" }
			id => "header-0001"
			add_field => {
				"[rsa][header][id]" => "0001"
				"[rsa][message][id2]" => "%{messageid}"
				"[logstash][headerfound]" => true
			}
		}
	}
	# HEADER 0002
	# line in RSA: %IBMICSFTVM-4: <!payload>
	if ![logstash][headerfound] {
		dissect {
			mapping => { "[event][original]" => "%IBMICSFTVM-4: %{message}" }
			id => "header-0002"
			add_field => {
				"[rsa][header][id]" => "0002"
				"[rsa][message][id2]" => "IBMICSF_TVM"
				"[logstash][headerfound]" => true
			}
		}
	}



################## MsgId2 to Parser ##################

	translate {
		field => "[rsa][message][id2]"
		destination => "[logstash][msgparser][id]"
		dictionary_path => "msgid2parserid-ibmicsfmsg.json"
		fallback => ""
		override => true
	}


################## MESSAGES ##################

	# PARSER msgParserId0
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|CCVE_Status=<fld4>|CCVT_Status=<fld5>|CryptoDomainIndex=<fld6>|TraceEntries=<fld7>|CKDSRead=<fld8>|DataLength=<fld9>|UserParm=<fld10>|PKDS=<fld11>|TKDS=<fld12>|
	if [logstash][msgparser][id] == "msgParserId0" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|CCVE_Status=%{fld4}|CCVT_Status=%{fld5}|CryptoDomainIndex=%{fld6}|TraceEntries=%{fld7}|CKDSRead=%{fld8}|DataLength=%{fld9}|UserParm=%{fld10}|PKDS=%{fld11}|TKDS=%{fld12}|" }
			id => "msgParserId0"
			add_field => {
				"action" => "ICSF is started"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId1
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|NumberStatus_ChangeSections=<fld4>|SCSSection=<fld5>|CPUNumber=<fld6>|KSUNumber=<fld7>|DomainIndex=<fld8>|CurrentMasterKeyVersion=<fld9>|CPStatus=<fld10>|StatusIndicator=<fld11>|MK_Verif_Pattern=<fld12>|NMK_Auth_Pattern=<fld13>|NMK_Verif_Pattern=<fld14>|OMK_Verif_Pattern=<fld15>|
	else if [logstash][msgparser][id] == "msgParserId1" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|NumberStatus_ChangeSections=%{fld4}|SCSSection=%{fld5}|CPUNumber=%{fld6}|KSUNumber=%{fld7}|DomainIndex=%{fld8}|CurrentMasterKeyVersion=%{fld9}|CPStatus=%{fld10}|StatusIndicator=%{fld11}|MK_Verif_Pattern=%{fld12}|NMK_Auth_Pattern=%{fld13}|NMK_Verif_Pattern=%{fld14}|OMK_Verif_Pattern=%{fld15}|" }
			id => "msgParserId1"
			add_field => {
				"action" => "change in the number of available processors"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId2
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|Code3Status=<fld4>|CPUNumber=<fld5>|Curr_CryptoDomain=<fld6>|
	else if [logstash][msgparser][id] == "msgParserId2" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|Code3Status=%{fld4}|CPUNumber=%{fld5}|Curr_CryptoDomain=%{fld6}|" }
			id => "msgParserId2"
			add_field => {
				"action" => "ICSF handles error conditions for cryptographic feature"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId3
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|SSM=<fld4>
	else if [logstash][msgparser][id] == "msgParserId3" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|SSM=%{fld4}" }
			id => "msgParserId3"
			add_field => {
				"action" => "change to special security mode is detected"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId4
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|MKPart=<fld4>|NMK_Verif_Pattern=<fld5>|Verif_Pattern=<fld6>|KSU=<fld7>|Curr_CryptoDomain=<fld8>|
	else if [logstash][msgparser][id] == "msgParserId4" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|MKPart=%{fld4}|NMK_Verif_Pattern=%{fld5}|Verif_Pattern=%{fld6}|KSU=%{fld7}|Curr_CryptoDomain=%{fld8}|" }
			id => "msgParserId4"
			add_field => {
				"action" => "key part is entered via the key entry unit"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId5
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|OperKey=<fld4>|OperKey_Verif_Pattern=<fld5>|CoProcNumber=<fld6>|Curr_CryptoDomain=<fld7>|CKDS=<fld8>|CKDS_Modified=<fld9>|
	else if [logstash][msgparser][id] == "msgParserId5" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|OperKey=%{fld4}|OperKey_Verif_Pattern=%{fld5}|CoProcNumber=%{fld6}|Curr_CryptoDomain=%{fld7}|CKDS=%{fld8}|CKDS_Modified=%{fld9}|" }
			id => "msgParserId5"
			add_field => {
				"action" => "key part is entered via the key entry unit"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId6
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|CKDS_Old=<fld4>|CKDS_New=<fld5>|
	else if [logstash][msgparser][id] == "msgParserId6" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|CKDS_Old=%{fld4}|CKDS_New=%{fld5}|" }
			id => "msgParserId6"
			add_field => {
				"action" => "In-storage copy of the CKDS is refreshed"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId7
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|CKDS_Update=<fld4>|CKDS=<fld5>|CKDS_Modified=<fld6>|
	else if [logstash][msgparser][id] == "msgParserId7" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|CKDS_Update=%{fld4}|CKDS=%{fld5}|CKDS_Modified=%{fld6}|" }
			id => "msgParserId7"
			add_field => {
				"action" => "CKDS is updated by a dynamic CKDS update "
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId8
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|PKA=<fld4>|MK_Hash=<fld5>|KP_HashPattern=<fld6>|KSUNumber=<fld7>|Curr_CryptoDomain=<fld8>|
	else if [logstash][msgparser][id] == "msgParserId8" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|PKA=%{fld4}|MK_Hash=%{fld5}|KP_HashPattern=%{fld6}|KSUNumber=%{fld7}|Curr_CryptoDomain=%{fld8}|" }
			id => "msgParserId8"
			add_field => {
				"action" => "clear key part is entered for one of the PKA master keys"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId9
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|MK_Entry=<fld4>|NMK_HashPattern=<fld5>|NMK_Verif_Pattern=<fld6>|KP_HashPattern=<fld7>|KP_Verif_Pattern=<fld8>|KSUNumber=<fld9>|Curr_CrptoDomain=<fld10>|
	else if [logstash][msgparser][id] == "msgParserId9" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|MK_Entry=%{fld4}|NMK_HashPattern=%{fld5}|NMK_Verif_Pattern=%{fld6}|KP_HashPattern=%{fld7}|KP_Verif_Pattern=%{fld8}|KSUNumber=%{fld9}|Curr_CrptoDomain=%{fld10}|" }
			id => "msgParserId9"
			add_field => {
				"action" => "clear key part is entered for the DES master key"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId10
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|PKSC_Request=<fld4>|AuthRegister=<fld8>|DomainIndex=<fld9>|KeyType=<fld10>|PKSC_ReplyType=<fld11>|ReplyLength=<fld12>|PKSC_Reply=<fld13>|CryptoModId=<fld14>|CryptoModSig=<fld15>|TransSeq=<fld16>|
	else if [logstash][msgparser][id] == "msgParserId10" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|PKSC_Request=%{fld4}|AuthRegister=%{fld8}|DomainIndex=%{fld9}|KeyType=%{fld10}|PKSC_ReplyType=%{fld11}|ReplyLength=%{fld12}|PKSC_Reply=%{fld13}|CryptoModId=%{fld14}|CryptoModSig=%{fld15}|TransSeq=%{fld16}|" }
			id => "msgParserId10"
			add_field => {
				"action" => "request and reply from calls to the CSFSPKSC service by TKE"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId11
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|PKDS_Update=<fld4>|PKDS=<fld5>|PKDS_modified=<fld6>|
	else if [logstash][msgparser][id] == "msgParserId11" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|PKDS_Update=%{fld4}|PKDS=%{fld5}|PKDS_modified=%{fld6}|" }
			id => "msgParserId11"
			add_field => {
				"action" => "PKDS is updated by a dynamic PKDS update service"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId12
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|AP_NMK=<fld4>|NMK_Verif_Pattern=<fld5>|KP_Verif_Pattern=<fld6>|CPUNumber=<fld7>|SerialNum=<fld8>|Curr_CrptoDomain=<fld9>|
	else if [logstash][msgparser][id] == "msgParserId12" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|AP_NMK=%{fld4}|NMK_Verif_Pattern=%{fld5}|KP_Verif_Pattern=%{fld6}|CPUNumber=%{fld7}|SerialNum=%{fld8}|Curr_CrptoDomain=%{fld9}|" }
			id => "msgParserId12"
			add_field => {
				"action" => "clear key part is entered for PCI Cryptographic Coprocessor master keys"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId13
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|CCR_key=<fld4>|RetKey=<fld5>|PCI_Proc=<fld6>|PCI_Serial=<fld7>|PCI_Domain=<fld8>|
	else if [logstash][msgparser][id] == "msgParserId13" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|CCR_key=%{fld4}|RetKey=%{fld5}|PCI_Proc=%{fld6}|PCI_Serial=%{fld7}|PCI_Domain=%{fld8}|" }
			id => "msgParserId13"
			add_field => {
				"action" => "PCI Cryptographic Coprocessor retained key is created or deleted"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId14
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|TKE=<fld4>|Recv_PCI_Index=<fld5>|Recv_PCI_Serial=<fld6>|Recv_PCI_Domain=<fld7>|Parm_BlockLen=<fld8>|Parm_DataLen=<fld9>|FuncId=<fld10>|FuncRC=<fld11>|Desc=<fld12>|UserId=<fld13>|TKE_auth=<fld14>|
	else if [logstash][msgparser][id] == "msgParserId14" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|TKE=%{fld4}|Recv_PCI_Index=%{fld5}|Recv_PCI_Serial=%{fld6}|Recv_PCI_Domain=%{fld7}|Parm_BlockLen=%{fld8}|Parm_DataLen=%{fld9}|FuncId=%{fld10}|FuncRC=%{fld11}|Desc=%{fld12}|UserId=%{fld13}|TKE_auth=%{fld14}|" }
			id => "msgParserId14"
			add_field => {
				"action" => "request and reply from calls to the CSFPCI service by TKE"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId15
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|<fld4>|Time_beforeNQAP=<fld5>|Time_afterDQAP=<fld6>|Time_afterWAIT=<fld7>|PCICC_queue=<fld8>|PCICC_SubFunc=<fld9>|PCICC_Index=<fld10>|PCICC_SerNum=<fld11>|Domain=<fld12>|RefNum=<fld13>|
	else if [logstash][msgparser][id] == "msgParserId15" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|%{fld4}|Time_beforeNQAP=%{fld5}|Time_afterDQAP=%{fld6}|Time_afterWAIT=%{fld7}|PCICC_queue=%{fld8}|PCICC_SubFunc=%{fld9}|PCICC_Index=%{fld10}|PCICC_SerNum=%{fld11}|Domain=%{fld12}|RefNum=%{fld13}|" }
			id => "msgParserId15"
			add_field => {
				"action" => "indication of PCI Cryptographic Coprocessor usage"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId16
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|OperConfig=<fld4>|OperIndex=<fld5>|Oper_SnNum=<fld6>|
	else if [logstash][msgparser][id] == "msgParserId16" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|OperConfig=%{fld4}|OperIndex=%{fld5}|Oper_SnNum=%{fld6}|" }
			id => "msgParserId16"
			add_field => {
				"action" => "PCI Cryptographic Processors and accelerators cam online or offline"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId17
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|<fld4>|Time_beforeNQAP=<fld5>|Time_afterDQAP=<fld6>|Time_afterWAIT=<fld7>|PCIXCC_queue=<fld8>|PCIXCC_SubFunc=<fld9>|PCIXCC_index=<fld10>|PCIXCC_SnNum=<fld11>|PCIXCC_Domain=<fld12>|PCIXCC_Ref=<fld13>|
	else if [logstash][msgparser][id] == "msgParserId17" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|%{fld4}|Time_beforeNQAP=%{fld5}|Time_afterDQAP=%{fld6}|Time_afterWAIT=%{fld7}|PCIXCC_queue=%{fld8}|PCIXCC_SubFunc=%{fld9}|PCIXCC_index=%{fld10}|PCIXCC_SnNum=%{fld11}|PCIXCC_Domain=%{fld12}|PCIXCC_Ref=%{fld13}|" }
			id => "msgParserId17"
			add_field => {
				"action" => "PCI X Cryptographic Coprocessor operation begins or ends"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId18
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|AP_ProcTiming=<fld4>|AP_Time_beforeNQAP=<fld5>|AP_Time_afterDQAP=<fld6>|AP_Time_afterWAIT=<fld7>|AP_queue=<fld8>|AP_SubFunc=<fld9>|AP_index=<fld10>|AP_SerNum=<fld11>|AP_Domain=<fld12>|AP_Ref=<fld13>|
	else if [logstash][msgparser][id] == "msgParserId18" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|AP_ProcTiming=%{fld4}|AP_Time_beforeNQAP=%{fld5}|AP_Time_afterDQAP=%{fld6}|AP_Time_afterWAIT=%{fld7}|AP_queue=%{fld8}|AP_SubFunc=%{fld9}|AP_index=%{fld10}|AP_SerNum=%{fld11}|AP_Domain=%{fld12}|AP_Ref=%{fld13}|" }
			id => "msgParserId18"
			add_field => {
				"action" => "ICSF to record processing times for PCIXCCs and CEX2Cs"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId19
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|Sysplex_group=<fld4>|Sysplex_member=<fld5>|Member action=<fld6>|Member status=<fld7>|Time_Join/Leave=<fld8>|CKDS/TKDS=<fld9>|
	else if [logstash][msgparser][id] == "msgParserId19" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|Sysplex_group=%{fld4}|Sysplex_member=%{fld5}|Member action=%{fld6}|Member status=%{fld7}|Time_Join/Leave=%{fld8}|CKDS/TKDS=%{fld9}|" }
			id => "msgParserId19"
			add_field => {
				"action" => "ICSF issued IXCJOIN to join the ICSF sysplex group or issued IXCLEAVE to leave the sysplex group"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId20
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|TB_CallType=<fld4>|ASID=<fld5>|TB_inputLabel=<fld6>|TB_outputLabel=<fld7>|TransportKeyIdLabel=<fld8>|
	else if [logstash][msgparser][id] == "msgParserId20" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|TB_CallType=%{fld4}|ASID=%{fld5}|TB_inputLabel=%{fld6}|TB_outputLabel=%{fld7}|TransportKeyIdLabel=%{fld8}|" }
			id => "msgParserId20"
			add_field => {
				"action" => "Trusted Block Create Callable services are invoked"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId21
	# line in RSA: SysId=<hostname>|SubSystem=<instance>|Timestamp=<fld3> <fld33>|TKDS_update=<fld4>|TKDS=<fld6>|TKDS_handle=<fld5>|
	else if [logstash][msgparser][id] == "msgParserId21" {
		dissect {
			mapping => { "message" => "SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{fld3} %{fld33}|TKDS_update=%{fld4}|TKDS=%{fld6}|TKDS_handle=%{fld5}|" }
			id => "msgParserId21"
			add_field => {
				"action" => "token data set (TKDS) is updated"
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId22
	# line in RSA: SMFType=<fld1>|SubType=<fld2>|SysId=<hostname>|SubSystem=<instance>|Timestamp=<event_time_string>|ENTRY_NAME=<event_type>|CCVEStatus=<fld7>|CCVTStatus=<fld8>|CryptoDomainIdx=<fld9>|TraceEntries=<fld10>|CKDSRead=<fld11>|DataLength=<fld12>|UserParm=<fld13>|PKDS=<fld14>|TKDS=<fld15>|NmbrStatChgSec=<fld16>|SCSSection=<fld17>|CPUNmbr=<fld18>|KSUNmbr=<fld19>|DomainIdx=<fld20>|CurrMstrKeyVersion=<fld21>|CPStatus=<fld22>|StatusIndicator=<fld23>|MKVerifPattern=<fld24>|NMKAuthPattern=<fld25>|NMKVerifPattern=<fld26>|OMKVerifPattern=<fld27>|Code3Status=<fld28>|CurrCryptoDomain=<fld29>|SSM=<fld30>|MKPart=<fld31>|VerifPattern=<fld32>|KSU=<fld33>|OperKey=<fld34>|OperKeyVerifPattern=<fld35>|CoProcNmbr=<fld36>|CKDS=<fld37>|CKDSModified=<fld38>|CKDSOld=<fld39>|CKDSNew=<fld40>|CKDSUpdate=<fld41>|PKA=<fld42>|MKHash=<fld43>|KPHashPattern=<fld44>|CNMKStatus=<fld45>|CNMKHashPattern=<fld46>|CNMKVerifPattern=<fld47>|KPVerifPattern=<fld48>|PKSCReqMsgType=<fld49>|UCQQueryId=<fld50>|SCBId=<fld51>|SCBTransSN=<fld52>|ReqLength=<fld53>|PKSCReq=<fld54>|AuthRegister=<fld55>|KeyType=<fld56>|PKSCReplyMsgType=<fld57>|PKSCReplyType=<fld58>|ReplyLength=<fld59>|PKSCReply=<fld60>|CryptoModId=<fld76>|CryptoModSig=<fld77>|TransSeq=<fld78>|PKDSUpdate=<fld79>|PKDSmodified=<fld80>|APNMK=<fld81>|SerialNum=<fld82>|CCRKey=<fld83>|RetKey=<fld84>|PCIProc=<fld85>|PCISerial=<fld86>|PCIDomain=<fld87>|TKE=<fld88>|RecvPCIIdx=<fld89>|RecvPCISerial=<fld90>|RecvPCIDomain=<fld91>|ParmBlockLength=<fld92>|ParmDataLength=<fld93>|FuncId=<fld94>|FuncRC=<fld95>|Desc=<fld96>|UserId=<fld97>|TKEAuth=<fld98>|TimeBeforeNQAP=<fld99>|TimeAfterDQAP=<fld100>|TimeAfterWAIT=<fld101>|PCICCQueue=<fld102>|PCICCSubFunc=<fld103>|PCICCIdx=<fld104>|PCICCSerNum=<fld105>|Domain=<fld106>|RefNum=<fld107>|OperConfig=<fld108>|OperIdx=<fld109>|OperSnNum=<fld110>|PCIXCCQueue=<fld111>|PCIXCCSubFunc=<fld112>|PCIXCCIdx=<fld113>|PCIXCCSnNum=<fld114>|PCIXCCDomain=<fld115>|PCIXCCRef=<fld116>|APProcTiming=<fld117>|APTimeBeforeNQAP=<fld118>|APTimeAfterDQAP=<fld119>|APTimeAfterWAIT=<fld120>|APQueue=<fld121>|APSubFunc=<fld122>|APIdx=<fld123>|APSerNum=<fld124>|APDomain=<fld125>|APRef=<fld126>|SysplexGroup=<fld127>|SysplexMember=<fld128>|MemberAction=<fld129>|MemberStatus=<fld130>|TimeJoinLeave=<fld131>|CKDS/TKDS=<fld132>|TBCallType=<fld133>|ASID=<fld134>|TBInput=<fld135>|TBInputLabel=<fld136>|TBOutput=<fld137>|TBOutputLabel=<fld138>|TransportKeyId=<fld139>|TransportKeyIdLabel=<fld140>|TKDSUpdate=<fld141>|TKDSHandle=<fld142>|
	else if [logstash][msgparser][id] == "msgParserId22" {
		dissect {
			mapping => { "message" => "SMFType=%{fld1}|SubType=%{fld2}|SysId=%{hostname}|SubSystem=%{instance}|Timestamp=%{event_time_string}|ENTRY_NAME=%{event_type}|CCVEStatus=%{fld7}|CCVTStatus=%{fld8}|CryptoDomainIdx=%{fld9}|TraceEntries=%{fld10}|CKDSRead=%{fld11}|DataLength=%{fld12}|UserParm=%{fld13}|PKDS=%{fld14}|TKDS=%{fld15}|NmbrStatChgSec=%{fld16}|SCSSection=%{fld17}|CPUNmbr=%{fld18}|KSUNmbr=%{fld19}|DomainIdx=%{fld20}|CurrMstrKeyVersion=%{fld21}|CPStatus=%{fld22}|StatusIndicator=%{fld23}|MKVerifPattern=%{fld24}|NMKAuthPattern=%{fld25}|NMKVerifPattern=%{fld26}|OMKVerifPattern=%{fld27}|Code3Status=%{fld28}|CurrCryptoDomain=%{fld29}|SSM=%{fld30}|MKPart=%{fld31}|VerifPattern=%{fld32}|KSU=%{fld33}|OperKey=%{fld34}|OperKeyVerifPattern=%{fld35}|CoProcNmbr=%{fld36}|CKDS=%{fld37}|CKDSModified=%{fld38}|CKDSOld=%{fld39}|CKDSNew=%{fld40}|CKDSUpdate=%{fld41}|PKA=%{fld42}|MKHash=%{fld43}|KPHashPattern=%{fld44}|CNMKStatus=%{fld45}|CNMKHashPattern=%{fld46}|CNMKVerifPattern=%{fld47}|KPVerifPattern=%{fld48}|PKSCReqMsgType=%{fld49}|UCQQueryId=%{fld50}|SCBId=%{fld51}|SCBTransSN=%{fld52}|ReqLength=%{fld53}|PKSCReq=%{fld54}|AuthRegister=%{fld55}|KeyType=%{fld56}|PKSCReplyMsgType=%{fld57}|PKSCReplyType=%{fld58}|ReplyLength=%{fld59}|PKSCReply=%{fld60}|CryptoModId=%{fld76}|CryptoModSig=%{fld77}|TransSeq=%{fld78}|PKDSUpdate=%{fld79}|PKDSmodified=%{fld80}|APNMK=%{fld81}|SerialNum=%{fld82}|CCRKey=%{fld83}|RetKey=%{fld84}|PCIProc=%{fld85}|PCISerial=%{fld86}|PCIDomain=%{fld87}|TKE=%{fld88}|RecvPCIIdx=%{fld89}|RecvPCISerial=%{fld90}|RecvPCIDomain=%{fld91}|ParmBlockLength=%{fld92}|ParmDataLength=%{fld93}|FuncId=%{fld94}|FuncRC=%{fld95}|Desc=%{fld96}|UserId=%{fld97}|TKEAuth=%{fld98}|TimeBeforeNQAP=%{fld99}|TimeAfterDQAP=%{fld100}|TimeAfterWAIT=%{fld101}|PCICCQueue=%{fld102}|PCICCSubFunc=%{fld103}|PCICCIdx=%{fld104}|PCICCSerNum=%{fld105}|Domain=%{fld106}|RefNum=%{fld107}|OperConfig=%{fld108}|OperIdx=%{fld109}|OperSnNum=%{fld110}|PCIXCCQueue=%{fld111}|PCIXCCSubFunc=%{fld112}|PCIXCCIdx=%{fld113}|PCIXCCSnNum=%{fld114}|PCIXCCDomain=%{fld115}|PCIXCCRef=%{fld116}|APProcTiming=%{fld117}|APTimeBeforeNQAP=%{fld118}|APTimeAfterDQAP=%{fld119}|APTimeAfterWAIT=%{fld120}|APQueue=%{fld121}|APSubFunc=%{fld122}|APIdx=%{fld123}|APSerNum=%{fld124}|APDomain=%{fld125}|APRef=%{fld126}|SysplexGroup=%{fld127}|SysplexMember=%{fld128}|MemberAction=%{fld129}|MemberStatus=%{fld130}|TimeJoinLeave=%{fld131}|CKDS/TKDS=%{fld132}|TBCallType=%{fld133}|ASID=%{fld134}|TBInput=%{fld135}|TBInputLabel=%{fld136}|TBOutput=%{fld137}|TBOutputLabel=%{fld138}|TransportKeyId=%{fld139}|TransportKeyIdLabel=%{fld140}|TKDSUpdate=%{fld141}|TKDSHandle=%{fld142}|" }
			id => "msgParserId22"
			add_field => {
				"[logstash][messagefound]" => true
			}
		}
	}


################## END OF MESSAGES ##################

# End of the filter block
}

# Enrich events using VALUEMAP
filter {
	translate {
		field => "[fld2]"
		destination => "[ec_subject]"
		dictionary => {
			"1" => "Event"
			"3" => "Configuration"
			"4" => "Service"
			"5" => "Configuration"
			"6" => "CryptoKey"
			"7" => "CryptoKey"
			"8" => "Process"
			"9" => "Process"
			"10" => "CryptoKey"
			"11" => "CryptoKey"
			"12" => "Service"
			"13" => "CryptoKey"
			"14" => "CryptoKey"
			"15" => "CryptoKey"
			"16" => "Service"
			"17" => "Process"
			"18" => "Process"
			"19" => "Event"
			"20" => "Process"
			"21" => "Process"
			"22" => "Service"
			"23" => "Process"
		}
		fallback => ""
		override => true
	}
}
filter {
	translate {
		field => "[fld2]"
		destination => "[ec_activity]"
		dictionary => {
			"1" => "Start"
			"3" => "Modify"
			"4" => "Execute"
			"5" => "Modify"
			"6" => "Request"
			"7" => "Request"
			"8" => "Request"
			"9" => "Request"
			"10" => "Request"
			"11" => "Request"
			"12" => "Request"
			"13" => "Modify"
			"14" => "Request"
			"15" => "Modify"
			"16" => "Request"
			"17" => "Request"
			"18" => "Request"
			"20" => "Request"
			"21" => "Request"
			"22" => "Request"
			"23" => "Request"
		}
		fallback => ""
		override => true
	}
}
filter {
	translate {
		field => "[fld2]"
		destination => "[ec_theme]"
		dictionary => {
			"3" => "Configuration"
			"5" => "Configuration"
			"6" => "Encryption"
			"7" => "Encryption"
			"10" => "Configuration"
			"11" => "Configuration"
			"13" => "Configuration"
			"14" => "Configuration"
			"15" => "Configuration"
			"22" => "Encryption"
		}
		fallback => ""
		override => true
	}
}
filter {
	translate {
		field => "[fld2]"
		destination => "[ec_outcome]"
		dictionary => {
			"4" => "Error"
		}
		fallback => ""
		override => true
	}
}
filter {
	translate {
		field => "[fld2]"
		destination => "[action]"
		dictionary => {
			"1" => "ICSF is started"
			"3" => "change in the number of available processors"
			"4" => "ICSF handles error conditions for cryptographic feature"
			"5" => "change to special security mode is detected"
			"6" => "key part is entered via the key entry unit"
			"7" => "key part is entered via the key entry unit"
			"8" => "In-storage copy of the CKDS is refreshed"
			"9" => "CKDS is updated by a dynamic CKDS update"
			"10" => "clear key part is entered for one of the PKA master keys"
			"11" => "clear key part is entered for the DES master key"
			"12" => "request and reply from calls to the CSFSPKSC service by TKE"
			"13" => "PKDS is updated by a dynamic PKDS update service"
			"14" => "clear key part is entered for PCI Cryptographic Coprocessor master keys"
			"15" => "PCI Cryptographic Coprocessor retained key is created or deleted"
			"16" => "request and reply from calls to the CSFPCI service by TKE"
			"17" => "indication of PCI Cryptographic Coprocessor usage"
			"18" => "PCI Cryptographic Processors and accelerators cam online or offline"
			"19" => "PCI X Cryptographic Coprocessor operation begins or ends"
			"20" => "ICSF to record processing times for PCIXCCs and CEX2Cs"
			"21" => "ICSF issued IXCJOIN to join the ICSF sysplex group or issued IXCLEAVE to leave the sysplex group"
			"22" => "Trusted Block Create Callable services are invoked"
			"23" => "token data set (TKDS) is updated"
		}
		fallback => ""
		override => true
	}
}


output {
#	if [logstash][headerfound] and [logstash][messagefound] {
#		elasticsearch {
#			hosts => ["https://elasticxxxxxx"]
#			index => "%{[observer][product]}-%{+YYYY.MM.dd}"
#			user => "logstash"
#			password => "abc"	# Better use keystore, cf https://www.elastic.co/guide/en/logstash/master/keystore.html
#			manage_template => true
#			template => "es-mapping-ibmicsfmsg.json"
#			template_name => "ibmicsf_template"
#			template_overwrite => true
#		}
#	} else {
#		# using a file output for logs that were not parsed correctly
#		# should you chose to send it to elasticsearch, please read https://discuss.elastic.co/t/latency-with-2-elasticsearch-systems/170074/2
#		file { path => "failed_logs-%{[observer][product]}-%{+YYYY-MM-dd}" }
#	}
	stdout {
		codec => rubydebug
	}
}

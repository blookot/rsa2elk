# Config file generated by RSA2ELK, see https://github.com/blookot/rsa2elk 
# Author: Vincent Maury
# Check all Netwitness parsers: https://github.com/netwitness/nw-logparsers/tree/master/devices/ (license: Apache 2.0)
# Check this link to search for source configuration guides: https://rsa.jiveon.com/community/products/netwitness/integrations/event-sources

##########
# CAUTION: check the "path" in input and "dictionary_path" in filter, as well as the "template" path in the elasticsearch output or "path" in the file output
##########

input {
#	syslog {
#		port => 514
#	}
#	file {
#		path => "/var/log/example.log"
#		start_position => "beginning"
#		sincedb_path => "/dev/null"
#	}
	generator {
		count => 1
		message => "a log line to test out"
	}
#	kafka {
#		codec => "json"
#		bootstrap_servers => "192.168.30.13:9092"
#		topics => ["mytopic"]
#		security_protocol => "SSL"
#		ssl_key_password => "{ssl_password}"
#		ssl_keystore_location => "/{keystore-absolute-path}"
#		ssl_keystore_password => "{keystore_password}"
#		ssl_truststore_location => "/{truststore-absolute-path}"
#		ssl_truststore_password => "{truststore_password}"
#	}
}

# Renaming a couple of fields
filter {
	mutate {
		rename => {
			"message" => "[event][original]"
			"host" => "[logstash][host]"
		}
	}
}

# Setting the device name and group
filter {
	mutate {
		add_field => {
			"[observer][product]" => "ciscomeraki"
			"[observer][name]" => "Cisco Meraki"
			"[observer][type]" => "Configuration Management"
		}
	}
}


# One single filter block for all headers and messages
filter {

################## HEADERS ##################

	# HEADER 0003
	# line in RSA: <hfld1> <hfld2>.<hfld3> { <hfld4>_appliance | <hfld4> } urls <!payload:hfld4>
	if ![logstash][headerfound] {
		grok {
			match => { "[event][original]" => "^(?<hfld1>[^\s]*)[\s]+(?<hfld2>[^\.]*)\.(?<hfld3>[^\s]*)[\s]+([\s]*(?<hfld4>[^_]*)_appliance[\s]+|[\s]*(?<hfld4>[^\s]*)[\s]+)[\s]+urls[\s]+(?<payload>.*))$" }
			id => "header-0003"
			add_field => {
				"[rsa][header][id]" => "0003"
				"[rsa][message][id2]" => "urls"
				"[logstash][headerfound]" => true
			}
		}
	}
	# HEADER 0002
	# line in RSA: <hfld1> <hfld2>.<hfld3> { <node>_appliance | <node> } events <!payload>
	if ![logstash][headerfound] {
		grok {
			match => { "[event][original]" => "^(?<hfld1>[^\s]*)[\s]+(?<hfld2>[^\.]*)\.(?<hfld3>[^\s]*)[\s]+([\s]*(?<node>[^_]*)_appliance[\s]+|[\s]*(?<node>[^\s]*)[\s]+)[\s]+events[\s]+(?<message>.*)$" }
			id => "header-0002"
			add_field => {
				"[rsa][header][id]" => "0002"
				"[rsa][message][id2]" => "events"
				"[logstash][headerfound]" => true
			}
		}
	}
	# HEADER 0001
	# line in RSA: <hfld1> <hfld2>.<hfld3> { <hfld4>_appliance | <hfld4> } <messageid> <!payload:hfld4>
	if ![logstash][headerfound] {
		grok {
			match => { "[event][original]" => "^(?<hfld1>[^\s]*)[\s]+(?<hfld2>[^\.]*)\.(?<hfld3>[^\s]*)[\s]+([\s]*(?<hfld4>[^_]*)_appliance[\s]+|[\s]*(?<hfld4>[^\s]*)[\s]+)[\s]+(?<messageid>[^\s]*)[\s]+(?<payload>.*))$" }
			id => "header-0001"
			add_field => {
				"[rsa][header][id]" => "0001"
				"[rsa][message][id2]" => "%{messageid}"
				"[logstash][headerfound]" => true
			}
		}
	}
	# HEADER 0005
	# line in RSA: <hfld1> <hfld2>.<hfld3> { <hfld4>_appliance | <hfld4> } <hfld5> <hfld6> <messageid> <!payload:hfld6>
	if ![logstash][headerfound] {
		grok {
			match => { "[event][original]" => "^(?<hfld1>[^\s]*)[\s]+(?<hfld2>[^\.]*)\.(?<hfld3>[^\s]*)[\s]+([\s]*(?<hfld4>[^_]*)_appliance[\s]+|[\s]*(?<hfld4>[^\s]*)[\s]+)[\s]+(?<hfld5>[^\s]*)[\s]+(?<message>(?<hfld6>[^\s]*)[\s]+(?<messageid>[^\s]*)[\s]+(?<payload>.*))$" }
			id => "header-0005"
			add_field => {
				"[rsa][header][id]" => "0005"
				"[rsa][message][id2]" => "%{messageid}"
				"[logstash][headerfound]" => true
			}
		}
	}
	# HEADER 0004
	# line in RSA: <hfld1> <hfld2>.<hfld3> <hfld4>_<space><messageid> <!payload>
	if ![logstash][headerfound] {
		dissect {
			mapping => { "[event][original]" => "%{hfld1} %{hfld2}.%{hfld3} %{hfld4}_%{space}%{messageid} %{message}" }
			id => "header-0004"
			add_field => {
				"[rsa][header][id]" => "0004"
				"[rsa][message][id2]" => "%{messageid}"
				"[logstash][headerfound]" => true
			}
		}
	}



################## MsgId2 to Parser ##################

	translate {
		field => "[rsa][message][id2]"
		destination => "[logstash][msgparser][id]"
		dictionary_path => "msgid2parserid-ciscomerakimsg.json"
		fallback => ""
		override => true
	}


################## MESSAGES ##################

	if [logstash][msgparser][id] == "flows" {
		# MESSAGE flows
		# line in RSA: { <node>_appliance | <node> } flows src=<saddr> { dst=<daddr> mac=<dmacaddr> | dst=<daddr> } { protocol=<protocol> sport=<sport> dport=<dport> |  protocol=<protocol> type=<event_type> | protocol=<protocol> } pattern: <fld21> <info>
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^([\s]*(?<node>[^_]*)_appliance[\s]+|[\s]*(?<node>[^\s]*)[\s]+)[\s]+flows[\s]+src=(?<saddr>[^\s]*)[\s]+([\s]*dst=(?<daddr>[^\s]*)[\s]+mac=(?<dmacaddr>[^\s]*)[\s]+|[\s]*dst=(?<daddr>[^\s]*)[\s]+)[\s]+([\s]*protocol=(?<protocol>[^\s]*)[\s]+sport=(?<sport>[^\s]*)[\s]+dport=(?<dport>[^\s]*)[\s]+|[\s]*protocol=(?<protocol>[^\s]*)[\s]+type=(?<event_type>[^\s]*)[\s]+|[\s]*protocol=(?<protocol>[^\s]*)[\s]+)[\s]+pattern:[\s]+(?<fld21>[^\s]*)[\s]+(?<info>.*)$" }
				id => "message-flows"
				add_field => {
				"event_source" => "appliance"
				"sensor" => "%{node}"
					"[event][id]" => "flows"
					"[rsa][message][id1]" => "flows"
					"[event][categoryid]" => "1605020000"
					"[logstash][fullDateTimeString]" => "%{hfld2}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
			}
		}
		# MESSAGE flows:01
		# line in RSA: <node> flows <action> src=<saddr> dst=<daddr> mac=<smacaddr> { protocol=<protocol> sport=<sport> dport=<dport> | protocol=<protocol> type=<event_type> | protocol=<protocol> } 
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^(?<node>[^\s]*)[\s]+flows[\s]+(?<action>[^\s]*)[\s]+src=(?<saddr>[^\s]*)[\s]+dst=(?<daddr>[^\s]*)[\s]+mac=(?<smacaddr>[^\s]*)[\s]+([\s]*protocol=(?<protocol>[^\s]*)[\s]+sport=(?<sport>[^\s]*)[\s]+dport=(?<dport>[^\s]*)[\s]+|[\s]*protocol=(?<protocol>[^\s]*)[\s]+type=(?<event_type>[^\s]*)[\s]+|[\s]*protocol=(?<protocol>[^\s]*)[\s]+)[\s]+$" }
				id => "message-flows:01"
				add_field => {
				"event_source" => "appliance"
				"sensor" => "%{node}"
					"[event][id]" => "flows:01"
					"[rsa][message][id1]" => "flows:01"
					"[event][categoryid]" => "1605020000"
					"[logstash][fullDateTimeString]" => "%{hfld2}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
			}
		}
		# MESSAGE flows:02
		# line in RSA: <node> flows <action>
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "%{node} flows %{action}" }
				id => "message-flows:02"
				add_field => {
				"event_source" => "appliance"
				"sensor" => "%{node}"
					"[event][id]" => "flows:02"
					"[rsa][message][id1]" => "flows:02"
					"[event][categoryid]" => "1605020000"
					"[logstash][fullDateTimeString]" => "%{hfld2}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
			}
		}
	}
	# PARSER msgParserId3
	# line in RSA: {<node>_appliance urls src=<saddr>:<sport>|<node> urls src=<saddr>:<sport>|src=<saddr>:<sport>} dst=<daddr>:<dport> mac=<macaddr> { agent='<user_agent>' request: <web_method> | agent=<user_agent> request: <web_method> | request: <web_method> } <url>
	else if [logstash][msgparser][id] == "msgParserId3" {
		grok {
			match => { "message" => "^((?<node>[^_]*)_appliance[\s]+urls[\s]+src=(?<saddr>[^:]*):(?<sport>[^\s]*)|(?<node>[^\s]*)[\s]+urls[\s]+src=(?<saddr>[^:]*):(?<sport>[^\s]*)|src=(?<saddr>[^:]*):(?<sport>[^\s]*))[\s]+dst=(?<daddr>[^:]*):(?<dport>[^\s]*)[\s]+mac=(?<macaddr>[^\s]*)[\s]+([\s]*agent='(?<user_agent>[^']*)'[\s]+request:[\s]+(?<web_method>[^\s]*)[\s]+|[\s]*agent=(?<user_agent>[^\s]*)[\s]+request:[\s]+(?<web_method>[^\s]*)[\s]+|[\s]*request:[\s]+(?<web_method>[^\s]*)[\s]+)[\s]+(?<url>.*)$" }
			id => "msgParserId3"
			add_field => {
				"event_source" => "appliance"
				"sensor" => "%{node}"
				"[logstash][fullDateTimeString]" => "%{hfld2}"
				"[logstash][messagefound]" => true
			}
		}
		if [logstash][fullDateTimeString] {
			date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
		}
	}
	else if [logstash][msgparser][id] == "events" {
		# MESSAGE events
		# line in RSA: dhcp lease of ip <saddr> from server mac <smacaddr> {for client mac <dmacaddr> with hostname <hostname>|for client mac <dmacaddr>} from router <hostip> on subnet <mask> with dns <dns_a_record>
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^dhcp[\s]+lease[\s]+of[\s]+ip[\s]+(?<saddr>[^\s]*)[\s]+from[\s]+server[\s]+mac[\s]+(?<smacaddr>[^\s]*)[\s]+(for[\s]+client[\s]+mac[\s]+(?<dmacaddr>[^\s]*)[\s]+with[\s]+hostname[\s]+(?<hostname>[^\s]*)|for[\s]+client[\s]+mac[\s]+(?<dmacaddr>[^\s]*))[\s]+from[\s]+router[\s]+(?<hostip>[^\s]*)[\s]+on[\s]+subnet[\s]+(?<mask>[^\s]*)[\s]+with[\s]+dns[\s]+(?<dns_a_record>.*)$" }
				id => "message-events"
				add_field => {
				"event_source" => "appliance"
				"sensor" => "%{node}"
					"[event][id]" => "events"
					"[rsa][message][id1]" => "events"
					"[event][categoryid]" => "1605020000"
					"[logstash][fullDateTimeString]" => "%{hfld2}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
			}
		}
		# MESSAGE events:02
		# line in RSA: content_filtering_block url='<url>' category0='<category>' { server='<daddr>:<dport>' client_mac='<dmacaddr>' | server='<daddr>:<dport>' }
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^content_filtering_block[\s]+url='(?<url>[^']*)'[\s]+category0='(?<category>[^']*)'[\s]+([\s]*server='(?<daddr>[^:]*):(?<dport>[^']*)'[\s]+client_mac='(?<dmacaddr>[^']*)'[\s]+|[\s]*server='(?<daddr>[^:]*):(?<dport>[^']*)'[\s]+)$" }
				id => "message-events:02"
				add_field => {
				"event_description" => "content_filtering_block"
				"sensor" => "%{node}"
					"[event][id]" => "events:02"
					"[rsa][message][id1]" => "events:02"
					"[event][categoryid]" => "1605020000"
					"[logstash][fullDateTimeString]" => "%{hfld2}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
			}
		}
		# MESSAGE events:01
		# line in RSA: aid=<fld1> arp_resp=<fld2> arp_src=<fld3> auth_neg_dur=<fld4> auth_neg_failed=<fld5> channel=<fld6> dns_req_rtt=<fld7> dns_resp=<fld8> dns_server=<fld9> duration=<duration> full_conn=<fld11> identity=<fld12> ip_resp=<fld13> ip_src=<saddr> is_8021x=<fld15> is_wpa=<fld16> last_auth_ago=<fld17> radio=<fld18> reason=<fld19> rssi=<dclass_ratio1> type=<event_type> vap=<fld22> client_mac=<dmacaddr> client_ip=<daddr> instigator=<fld20> http_resp=<fld21> dhcp_lease_completed=<fld22> dhcp_ip=<fld23> dhcp_server=<fld24> dhcp_server_mac=<fld25> dhcp_resp=<fld26> url=<url> category0=<category> server=<daddr> vpn_type=<fld27> connectivity=<fld28>
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "aid=%{fld1} arp_resp=%{fld2} arp_src=%{fld3} auth_neg_dur=%{fld4} auth_neg_failed=%{fld5} channel=%{fld6} dns_req_rtt=%{fld7} dns_resp=%{fld8} dns_server=%{fld9} duration=%{duration} full_conn=%{fld11} identity=%{fld12} ip_resp=%{fld13} ip_src=%{saddr} is_8021x=%{fld15} is_wpa=%{fld16} last_auth_ago=%{fld17} radio=%{fld18} reason=%{fld19} rssi=%{dclass_ratio1} type=%{event_type} vap=%{fld22} client_mac=%{dmacaddr} client_ip=%{daddr} instigator=%{fld20} http_resp=%{fld21} dhcp_lease_completed=%{fld22} dhcp_ip=%{fld23} dhcp_server=%{fld24} dhcp_server_mac=%{fld25} dhcp_resp=%{fld26} url=%{url} category0=%{category} server=%{daddr} vpn_type=%{fld27} connectivity=%{fld28}" }
				id => "message-events:01"
				add_field => {
				"event_source" => "appliance"
				"sensor" => "%{node}"
					"[event][id]" => "events:01"
					"[rsa][message][id1]" => "events:01"
					"[event][categoryid]" => "1605020000"
					"[logstash][fullDateTimeString]" => "%{hfld2}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
			}
		}
		# MESSAGE events:03
		# line in RSA: IDS: <info>
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "IDS: %{info}" }
				id => "message-events:03"
				add_field => {
				"event_description" => "events IDS"
				"sensor" => "%{node}"
					"[event][id]" => "events:03"
					"[rsa][message][id1]" => "events:03"
					"[event][categoryid]" => "1605020000"
					"[logstash][fullDateTimeString]" => "%{hfld2}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
			}
		}
		# MESSAGE events:04
		# line in RSA: dhcp {no offers|release} for mac <macaddr>
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^dhcp[\s]+(no[\s]+offers|release)[\s]+for[\s]+mac[\s]+(?<macaddr>.*)$" }
				id => "message-events:04"
				add_field => {
				"event_description" => "events DHCP"
				"sensor" => "%{node}"
					"[event][id]" => "events:04"
					"[rsa][message][id1]" => "events:04"
					"[event][categoryid]" => "1605020000"
					"[logstash][fullDateTimeString]" => "%{hfld2}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
			}
		}
		# MESSAGE events:05
		# line in RSA: MAC <macaddr> and MAC <macaddr> both claim IP: <saddr>
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "MAC %{macaddr} and MAC %{macaddr} both claim IP: %{saddr}" }
				id => "message-events:05"
				add_field => {
				"event_description" => " events MAC"
				"sensor" => "%{node}"
					"[event][id]" => "events:05"
					"[rsa][message][id1]" => "events:05"
					"[event][categoryid]" => "1605020000"
					"[logstash][fullDateTimeString]" => "%{hfld2}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
			}
		}
	}
	else if [logstash][msgparser][id] == "ids-alerts" {
		# MESSAGE ids-alerts:01
		# line in RSA: <node> ids-alerts signature=<fld1> priority=<fld2> timestamp=<fld3>.<fld4> {dhost=<dmacaddr>|shost=<smacaddr>} direction=<direction> protocol=<protocol> {src=<saddr>:<sport> dst=<daddr>:<dport>|src=<saddr> dst=<daddr>} message: <signame>
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^(?<node>[^\s]*)[\s]+ids\-alerts[\s]+signature=(?<fld1>[^\s]*)[\s]+priority=(?<fld2>[^\s]*)[\s]+timestamp=(?<fld3>[^\.]*)\.(?<fld4>[^\s]*)[\s]+(dhost=(?<dmacaddr>[^\s]*)|shost=(?<smacaddr>[^\s]*))[\s]+direction=(?<direction>[^\s]*)[\s]+protocol=(?<protocol>[^\s]*)[\s]+(src=(?<saddr>[^:]*):(?<sport>[^\s]*)[\s]+dst=(?<daddr>[^:]*):(?<dport>[^\s]*)|src=(?<saddr>[^\s]*)[\s]+dst=(?<daddr>[^\s]*))[\s]+message:[\s]+(?<signame>.*)$" }
				id => "message-ids-alerts:01"
				add_field => {
				"event_type" => "ids-alerts"
				"sensor" => "%{node}"
					"[event][id]" => "ids-alerts:01"
					"[rsa][message][id1]" => "ids-alerts:01"
					"[event][categoryid]" => "1607000000"
					"[logstash][fullDateTimeString]" => "%{fld3}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
			}
		}
		# MESSAGE ids-alerts:03
		# line in RSA: <node> ids-alerts signature=<fld1> priority=<fld2> timestamp=<fld3>.<fld4>direction=<direction> protocol=<protocol> src=<saddr>:<sport>
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "%{node} ids-alerts signature=%{fld1} priority=%{fld2} timestamp=%{fld3}.%{fld4}direction=%{direction} protocol=%{protocol} src=%{saddr}:%{sport}" }
				id => "message-ids-alerts:03"
				add_field => {
				"event_type" => "ids-alerts"
				"sensor" => "%{node}"
					"[event][id]" => "ids-alerts:03"
					"[rsa][message][id1]" => "ids-alerts:03"
					"[event][categoryid]" => "1607000000"
					"[logstash][fullDateTimeString]" => "%{fld3}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
			}
		}
		# MESSAGE ids-alerts:02
		# line in RSA: <node> ids-alerts signature=<fld1> priority=<fld2> timestamp=<fld3>.<fld4>protocol=<protocol> src=<saddr> dst=<daddr>message: <signame>
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "%{node} ids-alerts signature=%{fld1} priority=%{fld2} timestamp=%{fld3}.%{fld4}protocol=%{protocol} src=%{saddr} dst=%{daddr}message: %{signame}" }
				id => "message-ids-alerts:02"
				add_field => {
				"event_type" => "ids-alerts"
				"sensor" => "%{node}"
					"[event][id]" => "ids-alerts:02"
					"[rsa][message][id1]" => "ids-alerts:02"
					"[event][categoryid]" => "1607000000"
					"[logstash][fullDateTimeString]" => "%{fld3}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
			}
		}
	}
	else if [logstash][msgparser][id] == "security_event" {
		# MESSAGE security_event
		# line in RSA: <node>security_event <event_description> url=<url> src=<saddr>:<sport> dst=<daddr>:<dport> mac=<smacaddr> name=<fld10> sha256=<fld11> disposition=<disposition> action=<action>
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "%{node}security_event %{event_description} url=%{url} src=%{saddr}:%{sport} dst=%{daddr}:%{dport} mac=%{smacaddr} name=%{fld10} sha256=%{fld11} disposition=%{disposition} action=%{action}" }
				id => "message-security_event"
				add_field => {
				"event_type" => "security_event"
				"sensor" => "%{node}"
					"[event][id]" => "security_event"
					"[rsa][message][id1]" => "security_event"
					"[event][categoryid]" => "1605020000"
					"[logstash][fullDateTimeString]" => "%{hfld2}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
			}
		}
		# MESSAGE security_event:01
		# line in RSA: <node> security_event <event_description> signature=<fld1> priority=<fld2> timestamp=<fld3>.<fld4> {dhost=<dmacaddr>|shost=<smacaddr>} direction=<direction> protocol=<protocol> {src=<saddr>:<sport> dst=<daddr>:<dport>|src=<saddr> dst=<daddr>} message:<signame>
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^(?<node>[^\s]*)[\s]+security_event[\s]+(?<event_description>[^\s]*)[\s]+signature=(?<fld1>[^\s]*)[\s]+priority=(?<fld2>[^\s]*)[\s]+timestamp=(?<fld3>[^\.]*)\.(?<fld4>[^\s]*)[\s]+(dhost=(?<dmacaddr>[^\s]*)|shost=(?<smacaddr>[^\s]*))[\s]+direction=(?<direction>[^\s]*)[\s]+protocol=(?<protocol>[^\s]*)[\s]+(src=(?<saddr>[^:]*):(?<sport>[^\s]*)[\s]+dst=(?<daddr>[^:]*):(?<dport>[^\s]*)|src=(?<saddr>[^\s]*)[\s]+dst=(?<daddr>[^\s]*))[\s]+message:(?<signame>.*)$" }
				id => "message-security_event:01"
				add_field => {
				"event_type" => "security_event"
				"sensor" => "%{node}"
					"[event][id]" => "security_event:01"
					"[rsa][message][id1]" => "security_event:01"
					"[event][categoryid]" => "1607000000"
					"[logstash][fullDateTimeString]" => "%{fld3}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "UNIX" ] }
			}
		}
	}


################## END OF MESSAGES ##################

# End of the filter block
}

# Enrich events using VALUEMAP
filter {
	translate {
		field => "[fld21]"
		destination => "[action]"
		dictionary => {
			"0" => "Allow"
			"1" => "Deny"
			"allow" => "Allow"
		}
		fallback => ""
		override => true
	}
}


output {
#	if [logstash][headerfound] and [logstash][messagefound] {
#		elasticsearch {
#			hosts => ["https://elasticxxxxxx"]
#			index => "%{[observer][product]}-%{+YYYY.MM.dd}"
#			user => "logstash"
#			password => "abc"	# Better use keystore, cf https://www.elastic.co/guide/en/logstash/master/keystore.html
#			manage_template => true
#			template => "es-mapping-ciscomerakimsg.json"
#			template_name => "ciscomeraki_template"
#			template_overwrite => true
#		}
#	} else {
#		# using a file output for logs that were not parsed correctly
#		# should you chose to send it to elasticsearch, please read https://discuss.elastic.co/t/latency-with-2-elasticsearch-systems/170074/2
#		file { path => "failed_logs-%{[observer][product]}-%{+YYYY-MM-dd}" }
#	}
	stdout {
		codec => rubydebug
	}
}

# Config file generated by RSA2ELK, see https://github.com/blookot/rsa2elk 
# Author: Vincent Maury
# Check all Netwitness parsers: https://github.com/netwitness/nw-logparsers/tree/master/devices/ (license: Apache 2.0)
# Check this link to search for source configuration guides: https://rsa.jiveon.com/community/products/netwitness/integrations/event-sources

##########
# CAUTION: check the "path" in input and "dictionary_path" in filter, as well as the "template" path in the elasticsearch output or "path" in the file output
##########

input {
#	syslog {
#		port => 514
#	}
#	file {
#		path => "/var/log/example.log"
#		start_position => "beginning"
#		sincedb_path => "/dev/null"
#	}
	generator {
		count => 1
		message => "a log line to test out"
	}
#	kafka {
#		codec => "json"
#		bootstrap_servers => "192.168.30.13:9092"
#		topics => ["mytopic"]
#		security_protocol => "SSL"
#		ssl_key_password => "{ssl_password}"
#		ssl_keystore_location => "/{keystore-absolute-path}"
#		ssl_keystore_password => "{keystore_password}"
#		ssl_truststore_location => "/{truststore-absolute-path}"
#		ssl_truststore_password => "{truststore_password}"
#	}
}

# Renaming a couple of fields
filter {
	mutate {
		rename => {
			"message" => "[event][original]"
			"host" => "[logstash][host]"
		}
	}
}

# Setting the device name and group
filter {
	mutate {
		add_field => {
			"[observer][product]" => "barracudasf"
			"[observer][name]" => "Barracuda Spam Firewall"
			"[observer][type]" => "Anti Virus"
		}
	}
}


# One single filter block for all headers and messages
filter {

################## HEADERS ##################

	# HEADER 0001
	# line in RSA: <messageid>[<hfld14>]: <!payload:messageid>
	if ![logstash][headerfound] {
		grok {
			match => { "[event][original]" => "^(?<message>(?<messageid>[^\[]*)\[(?<hfld14>[^\]]*)\]:[\s]+(?<payload>.*))$" }
			id => "header-0001"
			add_field => {
				"[rsa][header][id]" => "0001"
				"[rsa][message][id2]" => "%{messageid}"
				"[logstash][headerfound]" => true
			}
		}
	}
	# HEADER 0002
	# line in RSA: <hfld1>/<messageid>[<hfld14>]: <!payload:hfld1>
	if ![logstash][headerfound] {
		grok {
			match => { "[event][original]" => "^(?<message>(?<hfld1>[^/]*)/(?<messageid>[^\[]*)\[(?<hfld14>[^\]]*)\]:[\s]+(?<payload>.*))$" }
			id => "header-0002"
			add_field => {
				"[rsa][header][id]" => "0002"
				"[rsa][message][id2]" => "%{messageid}"
				"[logstash][headerfound]" => true
			}
		}
	}
	# HEADER 0003
	# line in RSA: <messageid>: <!payload:messageid>
	if ![logstash][headerfound] {
		grok {
			match => { "[event][original]" => "^(?<message>(?<messageid>[^:]*):[\s]+(?<payload>.*))$" }
			id => "header-0003"
			add_field => {
				"[rsa][header][id]" => "0003"
				"[rsa][message][id2]" => "%{messageid}"
				"[logstash][headerfound]" => true
			}
		}
	}



################## MsgId2 to Parser ##################

	translate {
		field => "[rsa][message][id2]"
		destination => "[logstash][msgparser][id]"
		dictionary_path => "msgid2parserid-v20_barracudasfmsg.json"
		fallback => ""
		override => true
	}


################## MESSAGES ##################

	if [logstash][msgparser][id] == "inbound/pass1" {
		# MESSAGE 000001
		# line in RSA: inbound/pass1[<fld14>]: <username>[<saddr>] <id> <fld1> <fld2> RECV <from> <to> {<fld3> <resultcode> <info>|<info>}
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^inbound/pass1\[(?<fld14>[^\]]*)\]:[\s]+(?<username>[^\[]*)\[(?<saddr>[^\]]*)\][\s]+(?<id>[^\s]*)[\s]+(?<fld1>[^\s]*)[\s]+(?<fld2>[^\s]*)[\s]+RECV[\s]+(?<from>[^\s]*)[\s]+(?<to>[^\s]*)[\s]+((?<fld3>[^\s]*)[\s]+(?<resultcode>[^\s]*)[\s]+(?<info>.*)|(?<info>.*))$" }
				id => "message-000001"
				add_field => {
				"direction" => "inbound"
				"action" => " RECV"
					"[event][id]" => "000001"
					"[rsa][message][id1]" => "000001"
					"[event][categoryid]" => "1207010201"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE inbound/pass1
		# line in RSA: inbound/pass1: <web_domain>[<saddr>] <id> <fld1> <fld2> SCAN <fld4> <from> <to> <fld5> <fld3> <resultcode> {<fld6> SZ:<fld8> SUBJ:<subject>|<domain> <info>}
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^inbound/pass1:[\s]+(?<web_domain>[^\[]*)\[(?<saddr>[^\]]*)\][\s]+(?<id>[^\s]*)[\s]+(?<fld1>[^\s]*)[\s]+(?<fld2>[^\s]*)[\s]+SCAN[\s]+(?<fld4>[^\s]*)[\s]+(?<from>[^\s]*)[\s]+(?<to>[^\s]*)[\s]+(?<fld5>[^\s]*)[\s]+(?<fld3>[^\s]*)[\s]+(?<resultcode>[^\s]*)[\s]+((?<fld6>[^\s]*)[\s]+SZ:(?<fld8>[^\s]*)[\s]+SUBJ:(?<subject>.*)|(?<domain>[^\s]*)[\s]+(?<info>.*))$" }
				id => "message-inbound/pass1"
				add_field => {
				"direction" => "inbound"
				"action" => " SCAN"
					"[event][id]" => "inbound/pass1"
					"[rsa][message][id1]" => "inbound/pass1"
					"[event][categoryid]" => "1207010201"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE inbound/pass1:01
		# line in RSA: inbound/pass1:<web_domain>[<saddr>] <id> <fld1> <fld2> RECV <from> <to>{<fld3> <resultcode> <info>|<info>}
		# Parsing error: Couldn't parse because of 2 adjacent fields like <fld1>{a|<fld2>}
	}
	else if [logstash][msgparser][id] == "outbound/smtp" {
		# MESSAGE 000002
		# line in RSA: outbound/smtp[<fld14>]: <saddr> <id> <fld1> <fld2> <action> {<fld4> <fld3> <sessionid> <resultcode> <info>|<info>}
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^outbound/smtp\[(?<fld14>[^\]]*)\]:[\s]+(?<saddr>[^\s]*)[\s]+(?<id>[^\s]*)[\s]+(?<fld1>[^\s]*)[\s]+(?<fld2>[^\s]*)[\s]+(?<action>[^\s]*)[\s]+((?<fld4>[^\s]*)[\s]+(?<fld3>[^\s]*)[\s]+(?<sessionid>[^\s]*)[\s]+(?<resultcode>[^\s]*)[\s]+(?<info>.*)|(?<info>.*))$" }
				id => "message-000002"
				add_field => {
				"direction" => "outbound"
					"[event][id]" => "000002"
					"[rsa][message][id1]" => "000002"
					"[event][categoryid]" => "1207010000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE outbound/smtp
		# line in RSA: outbound/smtp: <saddr> <fld5> <fld1> <fld2> <action> <fld4> <fld3> <sessionid> <resultcode> {<fld8> <<<from>> |<<<from>>}  {[InternalId=<id>, Hostname=<hostname>] <event_description> #to#<ddomain> | [InternalId=<id>] <event_description> #to#<daddr> | [InternalId=<id>, Hostname=<hostname>] <info> | <event_description> #to#<ddomain>[<daddr>]:<dport> | <event_description> #to#<ddomain>}
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^outbound/smtp:[\s]+(?<saddr>[^\s]*)[\s]+(?<fld5>[^\s]*)[\s]+(?<fld1>[^\s]*)[\s]+(?<fld2>[^\s]*)[\s]+(?<action>[^\s]*)[\s]+(?<fld4>[^\s]*)[\s]+(?<fld3>[^\s]*)[\s]+(?<sessionid>[^\s]*)[\s]+(?<resultcode>[^\s]*)[\s]+((?<fld8>[^\s]*)[\s]+<(?<from>[^>]*)>[\s]+|<(?<from>[^>]*)>)[\s]+(\[InternalId=(?<id>[^,]*),[\s]+Hostname=(?<hostname>[^\]]*)\][\s]+(?<event_description>[^\s]*)[\s]+#to#(?<ddomain>[^\s]*)[\s]+|[\s]*\[InternalId=(?<id>[^\]]*)\][\s]+(?<event_description>[^\s]*)[\s]+#to#(?<daddr>[^\s]*)[\s]+|[\s]*\[InternalId=(?<id>[^,]*),[\s]+Hostname=(?<hostname>[^\]]*)\][\s]+(?<info>[^\s]*)[\s]+|[\s]*(?<event_description>[^\s]*)[\s]+#to#(?<ddomain>[^\[]*)\[(?<daddr>[^\]]*)\]:(?<dport>[^\s]*)[\s]+|[\s]*(?<event_description>[^\s]*)[\s]+#to#(?<ddomain>.*))$" }
				id => "message-outbound/smtp"
				add_field => {
				"direction" => "outbound"
					"[event][id]" => "outbound/smtp"
					"[rsa][message][id1]" => "outbound/smtp"
					"[event][categoryid]" => "1207010000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE 000009
		# line in RSA: outbound/smtp: <saddr> <id> <fld1> <fld2> <action> <fld4> <fld3> <sessionid> <resultcode> {<fld8> ok<fld9>| ok<fld9>} Message <fld10> accepted #to#<ddomain>[<daddr>]:<dport>
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^outbound/smtp:[\s]+(?<saddr>[^\s]*)[\s]+(?<id>[^\s]*)[\s]+(?<fld1>[^\s]*)[\s]+(?<fld2>[^\s]*)[\s]+(?<action>[^\s]*)[\s]+(?<fld4>[^\s]*)[\s]+(?<fld3>[^\s]*)[\s]+(?<sessionid>[^\s]*)[\s]+(?<resultcode>[^\s]*)[\s]+((?<fld8>[^\s]*)[\s]+ok(?<fld9>[^\s]*)|[\s]*ok(?<fld9>[^\s]*))[\s]+Message[\s]+(?<fld10>[^\s]*)[\s]+accepted[\s]+#to#(?<ddomain>[^\[]*)\[(?<daddr>[^\]]*)\]:(?<dport>.*)$" }
				id => "message-000009"
				add_field => {
				"direction" => "outbound"
					"[event][id]" => "000009"
					"[rsa][message][id1]" => "000009"
					"[event][categoryid]" => "1207010000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE outbound/smtp:01
		# line in RSA: outbound/smtp: <saddr> <id> <fld1> <fld2> <action> <fld4> <fld3> <sessionid> <resultcode> Message accepted for delivery #to#<ddomain>[<daddr>]:<dport>
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "outbound/smtp: %{saddr} %{id} %{fld1} %{fld2} %{action} %{fld4} %{fld3} %{sessionid} %{resultcode} Message accepted for delivery #to#%{ddomain}[%{daddr}]:%{dport}" }
				id => "message-outbound/smtp:01"
				add_field => {
				"direction" => "outbound"
				"result" => " Message accepted for delivery"
					"[event][id]" => "outbound/smtp:01"
					"[rsa][message][id1]" => "outbound/smtp:01"
					"[event][categoryid]" => "1207010000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE outbound/smtp:02
		# line in RSA: outbound/smtp: <saddr> <id> <fld1> <fld2> <action> <fld4> <fld3> <sessionid> conversation with <fld5>[<fld6>] timed out while sending <fld7> #to#<ddomain>[<daddr>]:<dport> 
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "outbound/smtp: %{saddr} %{id} %{fld1} %{fld2} %{action} %{fld4} %{fld3} %{sessionid} conversation with %{fld5}[%{fld6}] timed out while sending %{fld7} #to#%{ddomain}[%{daddr}]:%{dport}" }
				id => "message-outbound/smtp:02"
				add_field => {
				"direction" => "outbound"
					"[event][id]" => "outbound/smtp:02"
					"[rsa][message][id1]" => "outbound/smtp:02"
					"[event][categoryid]" => "1207010000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE 000010
		# line in RSA: outbound/smtp: <saddr> <id> <fld1> <fld2> <action> <fld4> <fld3> <sessionid> <fld7> {Ok <fld9> <fld10> - gsmtp| Ok: queued as <fld9> |ok <fld9>| Ok (<fld9>)| OK <fld9> | <fld9> } #to#<daddr>
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^outbound/smtp:[\s]+(?<saddr>[^\s]*)[\s]+(?<id>[^\s]*)[\s]+(?<fld1>[^\s]*)[\s]+(?<fld2>[^\s]*)[\s]+(?<action>[^\s]*)[\s]+(?<fld4>[^\s]*)[\s]+(?<fld3>[^\s]*)[\s]+(?<sessionid>[^\s]*)[\s]+(?<fld7>[^\s]*)[\s]+(Ok[\s]+(?<fld9>[^\s]*)[\s]+(?<fld10>[^\s]*)[\s]+\-[\s]+gsmtp|[\s]*Ok:[\s]+queued[\s]+as[\s]+(?<fld9>[^\s]*)[\s]+|ok[\s]+(?<fld9>[^\s]*)|[\s]*Ok[\s]+\((?<fld9>[^\)]*)\)|[\s]*OK[\s]+(?<fld9>[^\s]*)[\s]+|[\s]*(?<fld9>[^\s]*)[\s]+)[\s]+#to#(?<daddr>.*)$" }
				id => "message-000010"
				add_field => {
				"direction" => "outbound"
					"[event][id]" => "000010"
					"[rsa][message][id1]" => "000010"
					"[event][categoryid]" => "1207010000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE 000011
		# line in RSA: outbound/smtp: <saddr> <id> <fld1> <fld2> <action> <fld4> <fld3> <sessionid>  connect to <ddomain>[<daddr>]: <event_description> 
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "outbound/smtp: %{saddr} %{id} %{fld1} %{fld2} %{action} %{fld4} %{fld3} %{sessionid}  connect to %{ddomain}[%{daddr}]: %{event_description}" }
				id => "message-000011"
				add_field => {
				"direction" => "outbound"
					"[event][id]" => "000011"
					"[rsa][message][id1]" => "000011"
					"[event][categoryid]" => "1207010000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE 000012
		# line in RSA: outbound/smtp: <saddr> <id> <fld1> <fld2> <action> <fld4> <fld3> <sessionid> <fld7> [<ddomain>]: <event_description> 
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "outbound/smtp: %{saddr} %{id} %{fld1} %{fld2} %{action} %{fld4} %{fld3} %{sessionid} %{fld7} [%{ddomain}]: %{event_description}" }
				id => "message-000012"
				add_field => {
				"direction" => "outbound"
					"[event][id]" => "000012"
					"[rsa][message][id1]" => "000012"
					"[event][categoryid]" => "1207010000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE 000013
		# line in RSA: outbound/smtp: <saddr> <id> <fld1> <fld2> <action> <fld4> <fld3> <sessionid> <resultcode> <fld7> <<<from>>: <event_description> 
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "outbound/smtp: %{saddr} %{id} %{fld1} %{fld2} %{action} %{fld4} %{fld3} %{sessionid} %{resultcode} %{fld7} <%{from}>: %{event_description}" }
				id => "message-000013"
				add_field => {
				"direction" => "outbound"
					"[event][id]" => "000013"
					"[rsa][message][id1]" => "000013"
					"[event][categoryid]" => "1207010000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE 000014
		# line in RSA: outbound/smtp: <saddr> <id> <fld1> <fld2> <action> <fld4> <fld3> <sessionid> <resultcode> <fld8> <event_description> 
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "outbound/smtp: %{saddr} %{id} %{fld1} %{fld2} %{action} %{fld4} %{fld3} %{sessionid} %{resultcode} %{fld8} %{event_description}" }
				id => "message-000014"
				add_field => {
				"direction" => "outbound"
					"[event][id]" => "000014"
					"[rsa][message][id1]" => "000014"
					"[event][categoryid]" => "1207010000"
					"[logstash][messagefound]" => true
				}
			}
		}
	}
	else if [logstash][msgparser][id] == "scan" {
		# MESSAGE 000003
		# line in RSA: scan[<fld14>]: <username>[<saddr>] <id> <fld1> <fld2> <action> <fld8>  <from> <to> <fld4> <fld3> <resultcode> <fld7> {SZ:<fld9> SUBJ:<subject>| <info>}
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^scan\[(?<fld14>[^\]]*)\]:[\s]+(?<username>[^\[]*)\[(?<saddr>[^\]]*)\][\s]+(?<id>[^\s]*)[\s]+(?<fld1>[^\s]*)[\s]+(?<fld2>[^\s]*)[\s]+(?<action>[^\s]*)[\s]+(?<fld8>[^\s]*)[\s]+(?<from>[^\s]*)[\s]+(?<to>[^\s]*)[\s]+(?<fld4>[^\s]*)[\s]+(?<fld3>[^\s]*)[\s]+(?<resultcode>[^\s]*)[\s]+(?<fld7>[^\s]*)[\s]+(SZ:(?<fld9>[^\s]*)[\s]+SUBJ:(?<subject>.*)|[\s]*(?<info>.*))$" }
				id => "message-000003"
				add_field => {
					"[event][id]" => "000003"
					"[rsa][message][id1]" => "000003"
					"[event][categoryid]" => "1207040000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE scan
		# line in RSA: scan: <web_domain>[<saddr>] <id> <fld1> <fld2> <action> <fld8> <from> <to> <fld4> <fld3> <resultcode> <fld7> {SZ:<fld9> SUBJ:<subject>| <info>} 
		if ![logstash][messagefound] {
			grok {
				match => { "message" => "^scan:[\s]+(?<web_domain>[^\[]*)\[(?<saddr>[^\]]*)\][\s]+(?<id>[^\s]*)[\s]+(?<fld1>[^\s]*)[\s]+(?<fld2>[^\s]*)[\s]+(?<action>[^\s]*)[\s]+(?<fld8>[^\s]*)[\s]+(?<from>[^\s]*)[\s]+(?<to>[^\s]*)[\s]+(?<fld4>[^\s]*)[\s]+(?<fld3>[^\s]*)[\s]+(?<resultcode>[^\s]*)[\s]+(?<fld7>[^\s]*)[\s]+(SZ:(?<fld9>[^\s]*)[\s]+SUBJ:(?<subject>[^\s]*)|[\s]*(?<info>[^\s]*))[\s]+$" }
				id => "message-scan"
				add_field => {
					"[event][id]" => "scan"
					"[rsa][message][id1]" => "scan"
					"[event][categoryid]" => "1207040000"
					"[logstash][messagefound]" => true
				}
			}
		}
	}
	else if [logstash][msgparser][id] == "web" {
		# MESSAGE 000004
		# line in RSA: web: Ret Policy Summary (Del:<fld1> Kept:<fld2>)
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "web: Ret Policy Summary (Del:%{fld1} Kept:%{fld2})" }
				id => "message-000004"
				add_field => {
					"[event][id]" => "000004"
					"[rsa][message][id1]" => "000004"
					"[event][categoryid]" => "1701020000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE 000005
		# line in RSA: web: [<saddr>] FAILED_LOGIN (<username>)
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "web: [%{saddr}] FAILED_LOGIN (%{username})" }
				id => "message-000005"
				add_field => {
				"ec_subject" => "User"
				"ec_activity" => "Logon"
				"ec_theme" => "Authentication"
				"ec_outcome" => "Failure"
				"action" => "FAILED_LOGIN"
					"[event][id]" => "000005"
					"[rsa][message][id1]" => "000005"
					"[event][categoryid]" => "1401030000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE 000006
		# line in RSA: web: Retention violating accounts: <fld1> total
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "web: Retention violating accounts: %{fld1} total" }
				id => "message-000006"
				add_field => {
					"[event][id]" => "000006"
					"[rsa][message][id1]" => "000006"
					"[event][categoryid]" => "1605000000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE 000007
		# line in RSA: web: [<saddr>] global CHANGE <category> (<info>)
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "web: [%{saddr}] global CHANGE %{category} (%{info})" }
				id => "message-000007"
				add_field => {
				"action" => "CHANGE"
					"[event][id]" => "000007"
					"[rsa][message][id1]" => "000007"
					"[event][categoryid]" => "1701020000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE 000029
		# line in RSA: web: [<saddr>] LOGOUT (<username>)
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "web: [%{saddr}] LOGOUT (%{username})" }
				id => "message-000029"
				add_field => {
				"ec_subject" => "User"
				"ec_activity" => "Logoff"
				"ec_theme" => "Authentication"
				"action" => "LOGOUT"
					"[event][id]" => "000029"
					"[rsa][message][id1]" => "000029"
					"[event][categoryid]" => "1401070000"
					"[logstash][messagefound]" => true
				}
			}
		}
		# MESSAGE 000030
		# line in RSA: web: [<saddr>] LOGIN (<username>)
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "web: [%{saddr}] LOGIN (%{username})" }
				id => "message-000030"
				add_field => {
				"ec_subject" => "User"
				"ec_activity" => "Logon"
				"ec_theme" => "Authentication"
				"action" => "LOGIN"
					"[event][id]" => "000030"
					"[rsa][message][id1]" => "000030"
					"[event][categoryid]" => "1401060000"
					"[logstash][messagefound]" => true
				}
			}
		}
	}
	# PARSER msgParserId21
	# line in RSA: notify/smtp[<fld14>]: <saddr> <fld1> <fld2> <action> <fld4> <fld3> <sessionid> <bytes> <version> <from> <info>
	else if [logstash][msgparser][id] == "msgParserId21" {
		dissect {
			mapping => { "message" => "notify/smtp[%{fld14}]: %{saddr} %{fld1} %{fld2} %{action} %{fld4} %{fld3} %{sessionid} %{bytes} %{version} %{from} %{info}" }
			id => "msgParserId21"
			add_field => {
				"[logstash][messagefound]" => true
			}
		}
	}
	# PARSER msgParserId22
	# line in RSA: reports: REPORTS (<process>) queued as <fld1>
	else if [logstash][msgparser][id] == "msgParserId22" {
		dissect {
			mapping => { "message" => "reports: REPORTS (%{process}) queued as %{fld1}" }
			id => "msgParserId22"
			add_field => {
				"event_description" => "report queued"
				"[logstash][messagefound]" => true
			}
		}
	}


################## END OF MESSAGES ##################

# End of the filter block
}

# Enrich events using VALUEMAP
filter {
	translate {
		field => "[fld3]"
		destination => "[disposition]"
		dictionary => {
			"0" => "Allowed Message"
			"1" => "Aborted Message"
			"2" => "Blocked Message"
			"3" => "Quarantined Message"
			"4" => "Tagged Message"
			"5" => "Deferred Message"
			"6" => "Per-User Quarantined Message"
			"7" => "Whitelisted Message"
			"8" => "Encrypted Message"
			"9" => "Redirected Message"
			"10" => "Attachments Stubbed"
		}
		fallback => ""
		override => true
	}
}
filter {
	translate {
		field => "[fld3]"
		destination => "[disposition]"
		dictionary => {
			"1" => "Delivered Message"
			"2" => "Rejected Message"
			"3" => "Deferred Message"
			"4" => "Expired Message"
		}
		fallback => ""
		override => true
	}
}
filter {
	translate {
		field => "[event_cat]"
		destination => "[event_cat_name]"
		dictionary => {
			"1207010100" => "Content.Email.Delivery.Success"
			"1207040200" => "Content.Email.Spam.Blocked"
			"1207040100" => "Content.Email.Spam.Suspect"
			"1207010201" => "Content.Email.Delivery.Error.Nondelivery Receipt"
			"1207010000" => "Content.Email.Delivery"
			"1207000000" => "Content.Email"
		}
		fallback => "Other.Default"
		override => true
	}
}
filter {
	translate {
		field => "[disposition]"
		destination => "[event_cat]"
		dictionary => {
			"Delivered Message" => "1207010100"
			"Rejected Message" => "1207040200"
			"Allowed Message" => "1207010100"
			"Aborted Message" => "1207040200"
			"Blocked Message" => "1207040200"
			"Quarantined Message" => "1207040100"
			"Tagged Message" => "1207040100"
			"Deferred Message" => "1207010201"
			"Per-User Quarantined Message" => "1207010000"
			"Whitelisted Message" => "1207010100"
			"Encrypted Message" => "1207010000"
			"Redirected Message" => "1207000000"
			"Attachments Stubbed" => "1207000000"
			"Expired Message" => "1207010000"
		}
		fallback => "1901000000"
		override => true
	}
}


output {
#	if [logstash][headerfound] and [logstash][messagefound] {
#		elasticsearch {
#			hosts => ["https://elasticxxxxxx"]
#			index => "%{[observer][product]}-%{+YYYY.MM.dd}"
#			user => "logstash"
#			password => "abc"	# Better use keystore, cf https://www.elastic.co/guide/en/logstash/master/keystore.html
#			manage_template => true
#			template => "es-mapping-v20_barracudasfmsg.json"
#			template_name => "barracudasf_template"
#			template_overwrite => true
#		}
#	} else {
#		# using a file output for logs that were not parsed correctly
#		# should you chose to send it to elasticsearch, please read https://discuss.elastic.co/t/latency-with-2-elasticsearch-systems/170074/2
#		file { path => "failed_logs-%{[observer][product]}-%{+YYYY-MM-dd}" }
#	}
	stdout {
		codec => rubydebug
	}
}

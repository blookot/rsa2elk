# Config file generated by RSA2ELK, see https://github.com/blookot/rsa2elk 
# Author: Vincent Maury
# Check all Netwitness parsers: https://github.com/netwitness/nw-logparsers/tree/master/devices/ (license: Apache 2.0)
# Check this link to search for source configuration guides: https://rsa.jiveon.com/community/products/netwitness/integrations/event-sources

##########
# CAUTION: check the "path" in input and "dictionary_path" in filter, as well as the "template" path in the elasticsearch output or "path" in the file output
##########

input {
#	syslog {
#		port => 514
#	}
#	file {
#		path => "/var/log/example.log"
#		start_position => "beginning"
#		sincedb_path => "/dev/null"
#	}
	generator {
		count => 1
		message => "a log line to test out"
	}
#	kafka {
#		codec => "json"
#		bootstrap_servers => "192.168.30.13:9092"
#		topics => ["mytopic"]
#		security_protocol => "SSL"
#		ssl_key_password => "{ssl_password}"
#		ssl_keystore_location => "/{keystore-absolute-path}"
#		ssl_keystore_password => "{keystore_password}"
#		ssl_truststore_location => "/{truststore-absolute-path}"
#		ssl_truststore_password => "{truststore_password}"
#	}
}

# Renaming a couple of fields
filter {
	mutate {
		rename => {
			"message" => "[event][original]"
			"host" => "[logstash][host]"
		}
	}
}

# Setting the device name and group
filter {
	mutate {
		add_field => {
			"[observer][product]" => "trendmicroscanmail"
			"[observer][name]" => "Trend Micro ScanMail"
			"[observer][type]" => "Application Firewall"
		}
	}
}


# One single filter block for all headers and messages
filter {

################## HEADERS ##################

	# HEADER 0001
	# line in RSA: %TRENDMICRO MessageID:<messageid>,<!payload>
	if ![logstash][headerfound] {
		dissect {
			mapping => { "[event][original]" => "%TRENDMICRO MessageID:%{messageid},%{message}" }
			id => "header-0001"
			add_field => {
				"[rsa][header][id]" => "0001"
				"[rsa][message][id2]" => "%{messageid}"
				"[logstash][headerfound]" => true
			}
		}
	}
	# HEADER 0002
	# line in RSA: <hmonth> <hday> <htime> <hfld1> <hfld2>: EVENTNUMBER=<messageid> <!payload:messageid>
	if ![logstash][headerfound] {
		grok {
			match => { "[event][original]" => "^(?<hmonth>[^\s]*)[\s]+(?<hday>[^\s]*)[\s]+(?<htime>[^\s]*)[\s]+(?<hfld1>[^\s]*)[\s]+(?<hfld2>[^:]*):[\s]+EVENTNUMBER=(?<message>(?<messageid>[^\s]*)[\s]+(?<payload>.*))$" }
			id => "header-0002"
			add_field => {
				"[rsa][header][id]" => "0002"
				"[rsa][message][id2]" => "%{messageid}"
				"[logstash][headerfound]" => true
			}
		}
	}



################## MsgId2 to Parser ##################

	translate {
		field => "[rsa][message][id2]"
		destination => "[logstash][msgparser][id]"
		dictionary_path => "msgid2parserid-trendmicroscanmailmsg.json"
		fallback => ""
		override => true
	}


################## MESSAGES ##################

	# PARSER msgParserId0
	# line in RSA: Server: <hostname>,Date/Time: <fld2>/<fld3>/<fld4> <fld5>:<fld6>:<fld7> <fld8>,Reason: <event_description>,Related information: <info>
	if [logstash][msgparser][id] == "msgParserId0" {
		dissect {
			mapping => { "message" => "Server: %{hostname},Date/Time: %{fld2}/%{fld3}/%{fld4} %{fld5}:%{fld6}:%{fld7} %{fld8},Reason: %{event_description},Related information: %{info}" }
			id => "msgParserId0"
			add_field => {
				"[logstash][fullDateTimeString]" => "%{fld2} %{fld3} %{fld4} %{fld5} %{fld6} %{fld7} %{fld8}"
				"[logstash][messagefound]" => true
			}
		}
		if [logstash][fullDateTimeString] {
			date { match => [ "[logstash][fullDateTimeString]", "MdyyyyHmssa" ] }
		}
	}
	# PARSER msgParserId1
	# line in RSA: Server: <hostname>,Date/Time: <fld2>/<fld3>/<fld4> <fld5>:<fld6>:<fld7> <fld8>,Reason: <event_description>,Related information: <info>,Task name:<rulename>
	else if [logstash][msgparser][id] == "msgParserId1" {
		dissect {
			mapping => { "message" => "Server: %{hostname},Date/Time: %{fld2}/%{fld3}/%{fld4} %{fld5}:%{fld6}:%{fld7} %{fld8},Reason: %{event_description},Related information: %{info},Task name:%{rulename}" }
			id => "msgParserId1"
			add_field => {
				"[logstash][fullDateTimeString]" => "%{fld2} %{fld3} %{fld4} %{fld5} %{fld6} %{fld7} %{fld8}"
				"[logstash][messagefound]" => true
			}
		}
		if [logstash][fullDateTimeString] {
			date { match => [ "[logstash][fullDateTimeString]", "MdyyyyHmssa" ] }
		}
	}
	# PARSER msgParserId2
	# line in RSA: <virusname> has been detected,and <action> has been taken on <fld2>/<fld3>/<fld4> <fld5>:<fld6>:<fld7> <fld8>.,Message details:,Server: <hostname>,Sender: <from>,Recipient: <to>,Subject: <subject>,Attachment name: <filename>
	else if [logstash][msgparser][id] == "msgParserId2" {
		dissect {
			mapping => { "message" => "%{virusname} has been detected,and %{action} has been taken on %{fld2}/%{fld3}/%{fld4} %{fld5}:%{fld6}:%{fld7} %{fld8}.,Message details:,Server: %{hostname},Sender: %{from},Recipient: %{to},Subject: %{subject},Attachment name: %{filename}" }
			id => "msgParserId2"
			add_field => {
				"[logstash][fullDateTimeString]" => "%{fld2} %{fld3} %{fld4} %{fld5} %{fld6} %{fld7} %{fld8}"
				"[logstash][messagefound]" => true
			}
		}
		if [logstash][fullDateTimeString] {
			date { match => [ "[logstash][fullDateTimeString]", "MdyyyyHmssa" ] }
		}
	}
	# PARSER msgParserId3
	# line in RSA: The <fld1> has been blocked,,and <action> has been taken on <fld2>/<fld3>/<fld4> <fld5>:<fld6>:<fld7> <fld8>.,Message details:,Server: <hostname>,Sender: <from>,Recipient: <to>,Subject: <subject>,Attachment name: <filename>
	else if [logstash][msgparser][id] == "msgParserId3" {
		dissect {
			mapping => { "message" => "The %{fld1} has been blocked,,and %{action} has been taken on %{fld2}/%{fld3}/%{fld4} %{fld5}:%{fld6}:%{fld7} %{fld8}.,Message details:,Server: %{hostname},Sender: %{from},Recipient: %{to},Subject: %{subject},Attachment name: %{filename}" }
			id => "msgParserId3"
			add_field => {
				"[logstash][fullDateTimeString]" => "%{fld2} %{fld3} %{fld4} %{fld5} %{fld6} %{fld7} %{fld8}"
				"[logstash][messagefound]" => true
			}
		}
		if [logstash][fullDateTimeString] {
			date { match => [ "[logstash][fullDateTimeString]", "MdyyyyHmssa" ] }
		}
	}
	# PARSER msgParserId4
	# line in RSA: This email has violated the <rulename>.,and <action> has been taken on <fld2>/<fld3>/<fld4> <fld5>:<fld6>:<fld7> <fld8>.,Message details:,Server: <hostname>,Sender: <from>,Recipient: <to>,Subject: <subject>
	else if [logstash][msgparser][id] == "msgParserId4" {
		dissect {
			mapping => { "message" => "This email has violated the %{rulename}.,and %{action} has been taken on %{fld2}/%{fld3}/%{fld4} %{fld5}:%{fld6}:%{fld7} %{fld8}.,Message details:,Server: %{hostname},Sender: %{from},Recipient: %{to},Subject: %{subject}" }
			id => "msgParserId4"
			add_field => {
				"[logstash][fullDateTimeString]" => "%{fld2} %{fld3} %{fld4} %{fld5} %{fld6} %{fld7} %{fld8}"
				"[logstash][messagefound]" => true
			}
		}
		if [logstash][fullDateTimeString] {
			date { match => [ "[logstash][fullDateTimeString]", "MdyyyyHmssa" ] }
		}
	}
	# PARSER msgParserId5
	# line in RSA: <url> has been detected as,suspicious URLs,and <action> has been ,taken on <fld2>/<fld3>/<fld4> <fld5>:<fld6>:<fld7> <fld8>.,Message details:,Server: <hostname>,Sender: <from>;,Recipient: <to>;,Subject: <subject>
	else if [logstash][msgparser][id] == "msgParserId5" {
		dissect {
			mapping => { "message" => "%{url} has been detected as,suspicious URLs,and %{action} has been ,taken on %{fld2}/%{fld3}/%{fld4} %{fld5}:%{fld6}:%{fld7} %{fld8}.,Message details:,Server: %{hostname},Sender: %{from};,Recipient: %{to};,Subject: %{subject}" }
			id => "msgParserId5"
			add_field => {
				"[logstash][fullDateTimeString]" => "%{fld2} %{fld3} %{fld4} %{fld5} %{fld6} %{fld7} %{fld8}"
				"[logstash][messagefound]" => true
			}
		}
		if [logstash][fullDateTimeString] {
			date { match => [ "[logstash][fullDateTimeString]", "MdyyyyHmssa" ] }
		}
	}
	else if [logstash][msgparser][id] == "Virus_Outbreak" {
		# MESSAGE Virus_Outbreak:hours
		# line in RSA: Server: <hostname>,Date/Time: <fld2>/<fld3>/<fld4> <fld5>:<fld6>:<fld7> <fld8>,Reason: <event_description>,Related information: Viruses detected <event_counter> within <duration> hr(s)
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "Server: %{hostname},Date/Time: %{fld2}/%{fld3}/%{fld4} %{fld5}:%{fld6}:%{fld7} %{fld8},Reason: %{event_description},Related information: Viruses detected %{event_counter} within %{duration} hr(s)" }
				id => "message-Virus_Outbreak:hours"
				add_field => {
					"[event][id]" => "Virus_Outbreak:hours"
					"[rsa][message][id1]" => "Virus_Outbreak:hours"
					"[event][categoryid]" => "1003010000"
					"[logstash][fullDateTimeString]" => "%{fld2} %{fld3} %{fld4} %{fld5} %{fld6} %{fld7} %{fld8}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "MdyyyyHmssa" ] }
			}
		}
		# MESSAGE Virus_Outbreak:minutes
		# line in RSA: Server: <hostname>,Date/Time: <fld2>/<fld3>/<fld4> <fld5>:<fld6>:<fld7> <fld8>,Reason: <event_description>,Related information: Viruses detected <event_counter> within <duration> min(s)
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "Server: %{hostname},Date/Time: %{fld2}/%{fld3}/%{fld4} %{fld5}:%{fld6}:%{fld7} %{fld8},Reason: %{event_description},Related information: Viruses detected %{event_counter} within %{duration} min(s)" }
				id => "message-Virus_Outbreak:minutes"
				add_field => {
					"[event][id]" => "Virus_Outbreak:minutes"
					"[rsa][message][id1]" => "Virus_Outbreak:minutes"
					"[event][categoryid]" => "1003010000"
					"[logstash][fullDateTimeString]" => "%{fld2} %{fld3} %{fld4} %{fld5} %{fld6} %{fld7} %{fld8}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "MdyyyyHmssa" ] }
			}
		}
	}
	else if [logstash][msgparser][id] == "Virus_Uncleanable" {
		# MESSAGE Virus_Uncleanable:minutes
		# line in RSA: Server: <hostname>,Date/Time: <fld2>/<fld3>/<fld4> <fld5>:<fld6>:<fld7> <fld8>,Reason: <event_description>,Related information: Uncleanable viruses detected <event_counter> within <duration> min(s)
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "Server: %{hostname},Date/Time: %{fld2}/%{fld3}/%{fld4} %{fld5}:%{fld6}:%{fld7} %{fld8},Reason: %{event_description},Related information: Uncleanable viruses detected %{event_counter} within %{duration} min(s)" }
				id => "message-Virus_Uncleanable:minutes"
				add_field => {
					"[event][id]" => "Virus_Uncleanable:minutes"
					"[rsa][message][id1]" => "Virus_Uncleanable:minutes"
					"[event][categoryid]" => "1003010000"
					"[logstash][fullDateTimeString]" => "%{fld2} %{fld3} %{fld4} %{fld5} %{fld6} %{fld7} %{fld8}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "MdyyyyHmssa" ] }
			}
		}
		# MESSAGE Virus_Uncleanable:hours
		# line in RSA: Server: <hostname>,Date/Time: <fld2>/<fld3>/<fld4> <fld5>:<fld6>:<fld7> <fld8>,Reason: <event_description>,Related information: Uncleanable viruses detected <event_counter> within <duration> hr(s)
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "Server: %{hostname},Date/Time: %{fld2}/%{fld3}/%{fld4} %{fld5}:%{fld6}:%{fld7} %{fld8},Reason: %{event_description},Related information: Uncleanable viruses detected %{event_counter} within %{duration} hr(s)" }
				id => "message-Virus_Uncleanable:hours"
				add_field => {
					"[event][id]" => "Virus_Uncleanable:hours"
					"[rsa][message][id1]" => "Virus_Uncleanable:hours"
					"[event][categoryid]" => "1003010000"
					"[logstash][fullDateTimeString]" => "%{fld2} %{fld3} %{fld4} %{fld5} %{fld6} %{fld7} %{fld8}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "MdyyyyHmssa" ] }
			}
		}
	}
	else if [logstash][msgparser][id] == "AttachmentBlocked_Outbreak" {
		# MESSAGE AttachmentBlocked_Outbreak:minutes
		# line in RSA: Server: <hostname>,Date/Time: <fld2>/<fld3>/<fld4> <fld5>:<fld6>:<fld7> <fld8>,Reason: <event_description>,Related information: Blocked attachments detected <event_counter> within <duration> min(s)
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "Server: %{hostname},Date/Time: %{fld2}/%{fld3}/%{fld4} %{fld5}:%{fld6}:%{fld7} %{fld8},Reason: %{event_description},Related information: Blocked attachments detected %{event_counter} within %{duration} min(s)" }
				id => "message-AttachmentBlocked_Outbreak:minutes"
				add_field => {
					"[event][id]" => "AttachmentBlocked_Outbreak:minutes"
					"[rsa][message][id1]" => "AttachmentBlocked_Outbreak:minutes"
					"[event][categoryid]" => "1207000000"
					"[logstash][fullDateTimeString]" => "%{fld2} %{fld3} %{fld4} %{fld5} %{fld6} %{fld7} %{fld8}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "MdyyyyHmssa" ] }
			}
		}
		# MESSAGE AttachmentBlocked_Outbreak:hours
		# line in RSA: Server: <hostname>,Date/Time:<fld2>/<fld3>/<fld4> <fld5>:<fld6>:<fld7> <fld8>,Reason: <event_description>,Related information: Blocked attachments detected <event_counter> within <duration> hr(s)
		if ![logstash][messagefound] {
			dissect {
				mapping => { "message" => "Server: %{hostname},Date/Time:%{fld2}/%{fld3}/%{fld4} %{fld5}:%{fld6}:%{fld7} %{fld8},Reason: %{event_description},Related information: Blocked attachments detected %{event_counter} within %{duration} hr(s)" }
				id => "message-AttachmentBlocked_Outbreak:hours"
				add_field => {
					"[event][id]" => "AttachmentBlocked_Outbreak:hours"
					"[rsa][message][id1]" => "AttachmentBlocked_Outbreak:hours"
					"[event][categoryid]" => "1207000000"
					"[logstash][fullDateTimeString]" => "%{fld2} %{fld3} %{fld4} %{fld5} %{fld6} %{fld7} %{fld8}"
					"[logstash][messagefound]" => true
				}
			}
			if [logstash][fullDateTimeString] {
				date { match => [ "[logstash][fullDateTimeString]", "MdyyyyHmssa" ] }
			}
		}
	}
	# PARSER msgParserId12
	# line in RSA:  <id> TITLE=<event_type> TARGET=<daddr> (<fld1>) ACTIONBY=<event_source> DESCRIPTION=<event_description> (reason: <result>, last error code: <fld2>) TAGS=<fld3> 
	else if [logstash][msgparser][id] == "msgParserId12" {
		dissect {
			mapping => { "message" => "%{id} TITLE=%{event_type} TARGET=%{daddr} (%{fld1}) ACTIONBY=%{event_source} DESCRIPTION=%{event_description} (reason: %{result}, last error code: %{fld2}) TAGS=%{fld3}" }
			id => "msgParserId12"
			add_field => {
				"[logstash][messagefound]" => true
			}
		}
	}


################## END OF MESSAGES ##################

# End of the filter block
}


output {
#	if [logstash][headerfound] and [logstash][messagefound] {
#		elasticsearch {
#			hosts => ["https://elasticxxxxxx"]
#			index => "%{[observer][product]}-%{+YYYY.MM.dd}"
#			user => "logstash"
#			password => "abc"	# Better use keystore, cf https://www.elastic.co/guide/en/logstash/master/keystore.html
#			manage_template => true
#			template => "es-mapping-trendmicroscanmailmsg.json"
#			template_name => "trendmicroscanmail_template"
#			template_overwrite => true
#		}
#	} else {
#		# using a file output for logs that were not parsed correctly
#		# should you chose to send it to elasticsearch, please read https://discuss.elastic.co/t/latency-with-2-elasticsearch-systems/170074/2
#		file { path => "failed_logs-%{[observer][product]}-%{+YYYY-MM-dd}" }
#	}
	stdout {
		codec => rubydebug
	}
}
